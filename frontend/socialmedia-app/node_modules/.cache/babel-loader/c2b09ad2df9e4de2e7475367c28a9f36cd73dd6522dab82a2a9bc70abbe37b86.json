{"ast":null,"code":"/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n}\nconst TAB = String.fromCharCode(0x09);\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n  return result;\n};\n/**\n * Converts a string into a resolution object\n *\n * @param {string} resolution a string such as 3840x2160\n *\n * @return {Object} An object representing the resolution\n *\n */\n\nconst parseResolution = resolution => {\n  const split = resolution.split('x');\n  const result = {};\n  if (split[0]) {\n    result.width = parseInt(split[0], 10);\n  }\n  if (split[1]) {\n    result.height = parseInt(split[1], 10);\n  }\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n        if (match[2]) {\n          event.title = match[2];\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          if (event.attributes.RESOLUTION) {\n            event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n          }\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'i-frames-only'\n        });\n        return;\n      }\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'i-frame-playlist'\n        };\n        event.attributes = parseAttributes(match[1]);\n        if (event.attributes.URI) {\n          event.uri = event.attributes.URI;\n        }\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n        if (event.attributes.RESOLUTION) {\n          event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n        }\n        if (event.attributes['AVERAGE-BANDWIDTH']) {\n          event.attributes['AVERAGE-BANDWIDTH'] = parseInt(event.attributes['AVERAGE-BANDWIDTH'], 10);\n        }\n        if (event.attributes['FRAME-RATE']) {\n          event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'define'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n      return line;\n    };\n    this.tagMappers.push(mapFn);\n  }\n}\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n  if (!serverControl) {\n    return;\n  }\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @param {Object} [opts] Options for the constructor, needed for substitutions\n * @param {string} [opts.uri] URL to check for query params\n * @param {Object} [opts.mainDefinitions] Definitions on main playlist that can be imported\n * @extends Stream\n */\n\nclass Parser extends Stream {\n  constructor(opts = {}) {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.mainDefinitions = opts.mainDefinitions || {};\n    this.params = new URL(opts.uri, 'https://a.com').searchParams;\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n    const noop = function () {};\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      iFramePlaylists: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition; // Replace variables in uris and attributes as defined in #EXT-X-DEFINE tags\n\n      if (self.manifest.definitions) {\n        for (const def in self.manifest.definitions) {\n          if (entry.uri) {\n            entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);\n          }\n          if (entry.attributes) {\n            for (const attr in entry.attributes) {\n              if (typeof entry.attributes[attr] === 'string') {\n                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);\n              }\n            }\n          }\n        }\n      }\n      ({\n        tag() {\n          // switch based on the tag type\n          ({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange() {\n              const byterange = {};\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n            endlist() {\n              this.manifest.endList = true;\n            },\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n              this.manifest.segments = uris;\n            },\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map() {\n              currentMap = {};\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n              setHoldBack.call(this, this.manifest);\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n                if (!otherHint.type) {\n                  continue;\n                }\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n              setHoldBack.call(this, this.manifest);\n            },\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n              const endOnNextYes = !!dateRange.endOnNext;\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n            'i-frames-only'() {\n              this.manifest.iFramesOnly = true;\n              this.requiredCompatibilityversion(this.manifest.version, 4);\n            },\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            },\n            /** @this {Parser} */\n            define() {\n              this.manifest.definitions = this.manifest.definitions || {};\n              const addDef = (n, v) => {\n                if (n in this.manifest.definitions) {\n                  // An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other\n                  // EXT-X-DEFINE tag in the same Playlist.  Parsers that encounter duplicate\n                  // Variable Name declarations MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: Duplicate name ${n}`\n                  });\n                  return;\n                }\n                this.manifest.definitions[n] = v;\n              };\n              if ('QUERYPARAM' in entry.attributes) {\n                if ('NAME' in entry.attributes || 'IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n                const val = this.params.get(entry.attributes.QUERYPARAM);\n                if (!val) {\n                  // If the QUERYPARAM attribute value does not match any query parameter in\n                  // the URI or the matching parameter has no associated value, the parser\n                  // MUST fail to parse the Playlist.  If more than one parameter matches,\n                  // any of the associated values MAY be used.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`\n                  });\n                  return;\n                }\n                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));\n                return;\n              }\n              if ('NAME' in entry.attributes) {\n                if ('IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n                if (!('VALUE' in entry.attributes) || typeof entry.attributes.VALUE !== 'string') {\n                  // This attribute is REQUIRED if the EXT-X-DEFINE tag has a NAME attribute.\n                  // The quoted-string MAY be empty.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`\n                  });\n                  return;\n                }\n                addDef(entry.attributes.NAME, entry.attributes.VALUE);\n                return;\n              }\n              if ('IMPORT' in entry.attributes) {\n                if (!this.mainDefinitions[entry.attributes.IMPORT]) {\n                  // Covers two conditions, as mainDefinitions will always be empty on main\n                  //\n                  // EXT-X-DEFINE tags containing the IMPORT attribute MUST NOT occur in\n                  // Multivariant Playlists; they are only allowed in Media Playlists.\n                  //\n                  // If the IMPORT attribute value does not match any Variable Name in the\n                  // Multivariant Playlist, or if the Media Playlist loaded from a\n                  // Multivariant Playlist, the parser MUST fail the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`\n                  });\n                  return;\n                }\n                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);\n                return;\n              } // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a QUERYPARAM\n              // attribute, but only one of the three.  Otherwise, the client MUST fail to\n              // parse the Playlist.\n\n              this.trigger('error', {\n                message: 'EXT-X-DEFINE: No attribute'\n              });\n            },\n            'i-frame-playlist'() {\n              this.manifest.iFramePlaylists.push({\n                attributes: entry.attributes,\n                uri: entry.uri,\n                timeline: currentTimeline\n              });\n              this.warnOnMissingAttributes_('#EXT-X-I-FRAME-STREAM-INF', entry.attributes, ['BANDWIDTH', 'URI']);\n            }\n          }[entry.tagType] || noop).call(self);\n        },\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n          if (key) {\n            currentUri.key = key;\n          }\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n          currentUri = {};\n        },\n        comment() {// comments are not important for playback\n        },\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n  }\n  requiredCompatibilityversion(currentVersion, targetVersion) {\n    if (currentVersion < targetVersion || !currentVersion) {\n      this.trigger('warn', {\n        message: `manifest must be at least version ${targetVersion}`\n      });\n    }\n  }\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n}\nexport { LineStream, ParseStream, Parser };","map":{"version":3,"names":["Stream","_extends","decodeB64ToUint8Array","LineStream","constructor","buffer","push","data","nextNewline","indexOf","trigger","substring","TAB","String","fromCharCode","parseByterange","byterangeString","match","exec","result","length","parseInt","offset","attributeSeparator","key","value","keyvalue","RegExp","parseAttributes","attributes","attrs","split","i","attr","slice","replace","parseResolution","resolution","width","height","ParseStream","customParsers","tagMappers","line","event","trim","type","uri","newLines","reduce","acc","mapper","mappedLine","concat","forEach","newLine","call","text","tagType","duration","parseFloat","title","version","number","playlistType","allowed","test","URI","BYTERANGE","byterange","RESOLUTION","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","toLowerCase","Uint32Array","PRECISE","hasOwnProperty","subkey","toString","clientAttributePattern","isHexaDecimal","isDecimalFloating","addParser","expression","customType","dataParser","segment","addTagMapper","map","mapFn","camelCase","str","a","toUpperCase","camelCaseKeys","Object","keys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","tag","hb","phb","minTargetDuration","minPartDuration","message","Parser","opts","lineStream","parseStream","pipe","mainDefinitions","params","URL","searchParams","lastProgramDateTime","self","uris","currentUri","currentMap","hasParts","noop","defaultMediaGroups","widevineUuid","currentTimeline","allowCache","discontinuityStarts","dateRanges","iFramePlaylists","segments","lastByterangeEnd","lastPartByterangeEnd","dateRangeTags","on","parts","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","definitions","def","allow-cache","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","VALID_METHODS","KEYID","schemeIdUri","keyId","pssh","method","iv","media-sequence","isFinite","discontinuity-sequence","playlist-type","playlist","stream-inf","playlists","mediaGroups","media","TYPE","NAME","mediaGroupType","default","DEFAULT","autoselect","AUTOSELECT","LANGUAGE","language","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","program-date-time","getTime","reduceRight","programDateTime","targetduration","start","isNaN","timeOffset","precise","cue-out","cueOut","cue-out-cont","cueOutCont","cue-in","cueIn","skip","warnOnMissingAttributes_","part","segmentIndex","partIndex","renditionReports","r","server-control","canBlockReload","canSkipDateranges","preload-hint","hint","isPart","index","otherHint","rendition-report","report","required","part-inf","partInf","partTarget","daterange","dateRange","endDate","startDate","plannedDuration","endOnNextYes","endOnNext","class","newDateInSeconds","id","attribute","JSON","stringify","dateRangeWithSameId","findIndex","dateRangeToFind","pop","independent-segments","independentSegments","i-frames-only","iFramesOnly","requiredCompatibilityversion","content-steering","contentSteering","define","addDef","n","v","val","get","QUERYPARAM","decodeURIComponent","VALUE","IMPORT","i-frame-playlist","comment","custom","currentVersion","targetVersion","identifier","missing","join","chunk","end","options"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/m3u8-parser/dist/m3u8-parser.es.js"],"sourcesContent":["/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * Converts a string into a resolution object\n *\n * @param {string} resolution a string such as 3840x2160\n *\n * @return {Object} An object representing the resolution\n *\n */\n\n\nconst parseResolution = resolution => {\n  const split = resolution.split('x');\n  const result = {};\n\n  if (split[0]) {\n    result.width = parseInt(split[0], 10);\n  }\n\n  if (split[1]) {\n    result.height = parseInt(split[1], 10);\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'i-frames-only'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'i-frame-playlist'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.URI) {\n          event.uri = event.attributes.URI;\n        }\n\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n\n        if (event.attributes.RESOLUTION) {\n          event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n        }\n\n        if (event.attributes['AVERAGE-BANDWIDTH']) {\n          event.attributes['AVERAGE-BANDWIDTH'] = parseInt(event.attributes['AVERAGE-BANDWIDTH'], 10);\n        }\n\n        if (event.attributes['FRAME-RATE']) {\n          event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'define'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @param {Object} [opts] Options for the constructor, needed for substitutions\n * @param {string} [opts.uri] URL to check for query params\n * @param {Object} [opts.mainDefinitions] Definitions on main playlist that can be imported\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor(opts = {}) {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.mainDefinitions = opts.mainDefinitions || {};\n    this.params = new URL(opts.uri, 'https://a.com').searchParams;\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      iFramePlaylists: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition; // Replace variables in uris and attributes as defined in #EXT-X-DEFINE tags\n\n      if (self.manifest.definitions) {\n        for (const def in self.manifest.definitions) {\n          if (entry.uri) {\n            entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);\n          }\n\n          if (entry.attributes) {\n            for (const attr in entry.attributes) {\n              if (typeof entry.attributes[attr] === 'string') {\n                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);\n              }\n            }\n          }\n        }\n      }\n\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!dateRange.endOnNext;\n\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n\n            'i-frames-only'() {\n              this.manifest.iFramesOnly = true;\n              this.requiredCompatibilityversion(this.manifest.version, 4);\n            },\n\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            },\n\n            /** @this {Parser} */\n            define() {\n              this.manifest.definitions = this.manifest.definitions || {};\n\n              const addDef = (n, v) => {\n                if (n in this.manifest.definitions) {\n                  // An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other\n                  // EXT-X-DEFINE tag in the same Playlist.  Parsers that encounter duplicate\n                  // Variable Name declarations MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: Duplicate name ${n}`\n                  });\n                  return;\n                }\n\n                this.manifest.definitions[n] = v;\n              };\n\n              if ('QUERYPARAM' in entry.attributes) {\n                if ('NAME' in entry.attributes || 'IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                const val = this.params.get(entry.attributes.QUERYPARAM);\n\n                if (!val) {\n                  // If the QUERYPARAM attribute value does not match any query parameter in\n                  // the URI or the matching parameter has no associated value, the parser\n                  // MUST fail to parse the Playlist.  If more than one parameter matches,\n                  // any of the associated values MAY be used.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));\n                return;\n              }\n\n              if ('NAME' in entry.attributes) {\n                if ('IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                if (!('VALUE' in entry.attributes) || typeof entry.attributes.VALUE !== 'string') {\n                  // This attribute is REQUIRED if the EXT-X-DEFINE tag has a NAME attribute.\n                  // The quoted-string MAY be empty.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.NAME, entry.attributes.VALUE);\n                return;\n              }\n\n              if ('IMPORT' in entry.attributes) {\n                if (!this.mainDefinitions[entry.attributes.IMPORT]) {\n                  // Covers two conditions, as mainDefinitions will always be empty on main\n                  //\n                  // EXT-X-DEFINE tags containing the IMPORT attribute MUST NOT occur in\n                  // Multivariant Playlists; they are only allowed in Media Playlists.\n                  //\n                  // If the IMPORT attribute value does not match any Variable Name in the\n                  // Multivariant Playlist, or if the Media Playlist loaded from a\n                  // Multivariant Playlist, the parser MUST fail the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);\n                return;\n              } // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a QUERYPARAM\n              // attribute, but only one of the three.  Otherwise, the client MUST fail to\n              // parse the Playlist.\n\n\n              this.trigger('error', {\n                message: 'EXT-X-DEFINE: No attribute'\n              });\n            },\n\n            'i-frame-playlist'() {\n              this.manifest.iFramePlaylists.push({\n                attributes: entry.attributes,\n                uri: entry.uri,\n                timeline: currentTimeline\n              });\n              this.warnOnMissingAttributes_('#EXT-X-I-FRAME-STREAM-INF', entry.attributes, ['BANDWIDTH', 'URI']);\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  requiredCompatibilityversion(currentVersion, targetVersion) {\n    if (currentVersion < targetVersion || !currentVersion) {\n      this.trigger('warn', {\n        message: `manifest must be at least version ${targetVersion}`\n      });\n    }\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };\n"],"mappings":"AAAA;AACA,OAAOA,MAAM,MAAM,iCAAiC;AACpD,OAAOC,QAAQ,MAAM,gCAAgC;AACrD,OAAOC,qBAAqB,MAAM,oDAAoD;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,SAASH,MAAM,CAAC;EAC9BI,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,MAAM,GAAG,EAAE;EAClB;EACA;AACF;AACA;AACA;AACA;;EAGEC,IAAIA,CAACC,IAAI,EAAE;IACT,IAAIC,WAAW;IACf,IAAI,CAACH,MAAM,IAAIE,IAAI;IACnBC,WAAW,GAAG,IAAI,CAACH,MAAM,CAACI,OAAO,CAAC,IAAI,CAAC;IAEvC,OAAOD,WAAW,GAAG,CAAC,CAAC,EAAEA,WAAW,GAAG,IAAI,CAACH,MAAM,CAACI,OAAO,CAAC,IAAI,CAAC,EAAE;MAChE,IAAI,CAACC,OAAO,CAAC,MAAM,EAAE,IAAI,CAACL,MAAM,CAACM,SAAS,CAAC,CAAC,EAAEH,WAAW,CAAC,CAAC;MAC3D,IAAI,CAACH,MAAM,GAAG,IAAI,CAACA,MAAM,CAACM,SAAS,CAACH,WAAW,GAAG,CAAC,CAAC;IACtD;EACF;AAEF;AAEA,MAAMI,GAAG,GAAGC,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC;AAErC,MAAMC,cAAc,GAAG,SAAAA,CAAUC,eAAe,EAAE;EAChD;EACA;EACA,MAAMC,KAAK,GAAG,wBAAwB,CAACC,IAAI,CAACF,eAAe,IAAI,EAAE,CAAC;EAClE,MAAMG,MAAM,GAAG,CAAC,CAAC;EAEjB,IAAIF,KAAK,CAAC,CAAC,CAAC,EAAE;IACZE,MAAM,CAACC,MAAM,GAAGC,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACxC;EAEA,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;IACZE,MAAM,CAACG,MAAM,GAAGD,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACxC;EAEA,OAAOE,MAAM;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMI,kBAAkB,GAAG,SAAAA,CAAA,EAAY;EACrC,MAAMC,GAAG,GAAG,OAAO;EACnB,MAAMC,KAAK,GAAG,eAAe;EAC7B,MAAMC,QAAQ,GAAG,KAAK,GAAGF,GAAG,GAAG,OAAO,GAAGC,KAAK,GAAG,GAAG;EACpD,OAAO,IAAIE,MAAM,CAAC,UAAU,GAAGD,QAAQ,GAAG,GAAG,CAAC;AAChD,CAAC;AACD;AACA;AACA;AACA;AACA;;AAGA,MAAME,eAAe,GAAG,SAAAA,CAAUC,UAAU,EAAE;EAC5C,MAAMV,MAAM,GAAG,CAAC,CAAC;EAEjB,IAAI,CAACU,UAAU,EAAE;IACf,OAAOV,MAAM;EACf,CAAC,CAAC;;EAGF,MAAMW,KAAK,GAAGD,UAAU,CAACE,KAAK,CAACR,kBAAkB,CAAC,CAAC,CAAC;EACpD,IAAIS,CAAC,GAAGF,KAAK,CAACV,MAAM;EACpB,IAAIa,IAAI;EAER,OAAOD,CAAC,EAAE,EAAE;IACV;IACA,IAAIF,KAAK,CAACE,CAAC,CAAC,KAAK,EAAE,EAAE;MACnB;IACF,CAAC,CAAC;;IAGFC,IAAI,GAAG,cAAc,CAACf,IAAI,CAACY,KAAK,CAACE,CAAC,CAAC,CAAC,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAE/CD,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;IAC3CF,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;IAC3CF,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC,iBAAiB,EAAE,IAAI,CAAC;IAClDhB,MAAM,CAACc,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EAC3B;EAEA,OAAOd,MAAM;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMiB,eAAe,GAAGC,UAAU,IAAI;EACpC,MAAMN,KAAK,GAAGM,UAAU,CAACN,KAAK,CAAC,GAAG,CAAC;EACnC,MAAMZ,MAAM,GAAG,CAAC,CAAC;EAEjB,IAAIY,KAAK,CAAC,CAAC,CAAC,EAAE;IACZZ,MAAM,CAACmB,KAAK,GAAGjB,QAAQ,CAACU,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACvC;EAEA,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;IACZZ,MAAM,CAACoB,MAAM,GAAGlB,QAAQ,CAACU,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACxC;EAEA,OAAOZ,MAAM;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMqB,WAAW,SAASxC,MAAM,CAAC;EAC/BI,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACP,IAAI,CAACqC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,UAAU,GAAG,EAAE;EACtB;EACA;AACF;AACA;AACA;AACA;;EAGEpC,IAAIA,CAACqC,IAAI,EAAE;IACT,IAAI1B,KAAK;IACT,IAAI2B,KAAK,CAAC,CAAC;;IAEXD,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,CAAC;IAElB,IAAIF,IAAI,CAACvB,MAAM,KAAK,CAAC,EAAE;MACrB;MACA;IACF,CAAC,CAAC;;IAGF,IAAIuB,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACnB,IAAI,CAACjC,OAAO,CAAC,MAAM,EAAE;QACnBoC,IAAI,EAAE,KAAK;QACXC,GAAG,EAAEJ;MACP,CAAC,CAAC;MACF;IACF,CAAC,CAAC;;IAGF,MAAMK,QAAQ,GAAG,IAAI,CAACN,UAAU,CAACO,MAAM,CAAC,CAACC,GAAG,EAAEC,MAAM,KAAK;MACvD,MAAMC,UAAU,GAAGD,MAAM,CAACR,IAAI,CAAC,CAAC,CAAC;;MAEjC,IAAIS,UAAU,KAAKT,IAAI,EAAE;QACvB,OAAOO,GAAG;MACZ;MAEA,OAAOA,GAAG,CAACG,MAAM,CAAC,CAACD,UAAU,CAAC,CAAC;IACjC,CAAC,EAAE,CAACT,IAAI,CAAC,CAAC;IACVK,QAAQ,CAACM,OAAO,CAACC,OAAO,IAAI;MAC1B,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACS,aAAa,CAACrB,MAAM,EAAEY,CAAC,EAAE,EAAE;QAClD,IAAI,IAAI,CAACS,aAAa,CAACT,CAAC,CAAC,CAACwB,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC,EAAE;UAC7C;QACF;MACF,CAAC,CAAC;;MAGF,IAAIA,OAAO,CAAC9C,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;QACjC,IAAI,CAACC,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,SAAS;UACfW,IAAI,EAAEF,OAAO,CAACrB,KAAK,CAAC,CAAC;QACvB,CAAC,CAAC;QACF;MACF,CAAC,CAAC;MACF;;MAGAqB,OAAO,GAAGA,OAAO,CAACpB,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;;MAErClB,KAAK,GAAG,UAAU,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEhC,IAAItC,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAzC,KAAK,GAAG,8BAA8B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEpD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACe,QAAQ,GAAGC,UAAU,CAAC3C,KAAK,CAAC,CAAC,CAAC,CAAC;QACvC;QAEA,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACiB,KAAK,GAAG5C,KAAK,CAAC,CAAC,CAAC;QACxB;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,mCAAmC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEzD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACe,QAAQ,GAAGtC,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACzC;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,4BAA4B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAElD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACkB,OAAO,GAAGzC,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACxC;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,sCAAsC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE5D,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACmB,MAAM,GAAG1C,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACvC;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,8CAA8C,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEpE,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACmB,MAAM,GAAG1C,QAAQ,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACvC;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,8BAA8B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEpD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACoB,YAAY,GAAG/C,KAAK,CAAC,CAAC,CAAC;QAC/B;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,0BAA0B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEhD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG3C,QAAQ,CAACc,cAAc,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;UACzC6B,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAI,CAAChD,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,+BAA+B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAErD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACqB,OAAO,GAAG,CAAC,IAAI,CAACC,IAAI,CAACjD,KAAK,CAAC,CAAC,CAAC,CAAC;QACtC;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,mBAAmB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEzC,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ,MAAMY,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;UAE5C,IAAIY,UAAU,CAACsC,GAAG,EAAE;YAClBvB,KAAK,CAACG,GAAG,GAAGlB,UAAU,CAACsC,GAAG;UAC5B;UAEA,IAAItC,UAAU,CAACuC,SAAS,EAAE;YACxBxB,KAAK,CAACyB,SAAS,GAAGtD,cAAc,CAACc,UAAU,CAACuC,SAAS,CAAC;UACxD;QACF;QAEA,IAAI,CAAC1D,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,0BAA0B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEhD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;UAE5C,IAAI2B,KAAK,CAACf,UAAU,CAACyC,UAAU,EAAE;YAC/B1B,KAAK,CAACf,UAAU,CAACyC,UAAU,GAAGlC,eAAe,CAACQ,KAAK,CAACf,UAAU,CAACyC,UAAU,CAAC;UAC5E;UAEA,IAAI1B,KAAK,CAACf,UAAU,CAAC0C,SAAS,EAAE;YAC9B3B,KAAK,CAACf,UAAU,CAAC0C,SAAS,GAAGlD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC0C,SAAS,EAAE,EAAE,CAAC;UACvE;UAEA,IAAI3B,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,EAAE;YAClCe,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,GAAG+B,UAAU,CAAChB,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,CAAC;UAC7E;UAEA,IAAIe,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,EAAE;YAClCe,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,GAAGR,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,CAAC;UAC/E;QACF;QAEA,IAAI,CAACnB,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,qBAAqB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE3C,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC9C;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,iBAAiB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEvC,IAAItC,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAzC,KAAK,GAAG,uBAAuB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE7C,IAAItC,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAzC,KAAK,GAAG,iCAAiC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEvD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAAC4B,cAAc,GAAGvD,KAAK,CAAC,CAAC,CAAC;UAC/B2B,KAAK,CAAC6B,cAAc,GAAG,IAAIC,IAAI,CAACzD,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3C;QAEA,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,mBAAmB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEzC,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;UAE9C,IAAI2B,KAAK,CAACf,UAAU,CAAC8C,EAAE,EAAE;YACvB,IAAI/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAChE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAACiE,WAAW,CAAC,CAAC,KAAK,IAAI,EAAE;cAC9DhC,KAAK,CAACf,UAAU,CAAC8C,EAAE,GAAG/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAChE,SAAS,CAAC,CAAC,CAAC;YACxD;YAEAiC,KAAK,CAACf,UAAU,CAAC8C,EAAE,GAAG/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC1D,KAAK,CAAC,OAAO,CAAC;YACxD2B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,GAAGtD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC7D/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,GAAGtD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC7D/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,GAAGtD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC7D/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,GAAGtD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC7D/B,KAAK,CAACf,UAAU,CAAC8C,EAAE,GAAG,IAAIE,WAAW,CAACjC,KAAK,CAACf,UAAU,CAAC8C,EAAE,CAAC;UAC5D;QACF;QAEA,IAAI,CAACjE,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,qBAAqB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE3C,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;UAC5C2B,KAAK,CAACf,UAAU,CAAC,aAAa,CAAC,GAAG+B,UAAU,CAAChB,KAAK,CAACf,UAAU,CAAC,aAAa,CAAC,CAAC;UAC7Ee,KAAK,CAACf,UAAU,CAACiD,OAAO,GAAG,KAAK,CAACZ,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACiD,OAAO,CAAC;QACjE;QAEA,IAAI,CAACpE,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,6BAA6B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEnD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACrC,IAAI,GAAGU,KAAK,CAAC,CAAC,CAAC;QACvB,CAAC,MAAM;UACL2B,KAAK,CAACrC,IAAI,GAAG,EAAE;QACjB;QAEA,IAAI,CAACG,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,wBAAwB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE9C,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACrC,IAAI,GAAGU,KAAK,CAAC,CAAC,CAAC;QACvB,CAAC,MAAM;UACL2B,KAAK,CAACrC,IAAI,GAAG,EAAE;QACjB;QAEA,IAAI,CAACG,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,wBAAwB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE9C,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QAED,IAAIzC,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ2B,KAAK,CAACrC,IAAI,GAAGU,KAAK,CAAC,CAAC,CAAC;QACvB,CAAC,MAAM;UACL2B,KAAK,CAACrC,IAAI,GAAG,EAAE;QACjB;QAEA,IAAI,CAACG,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,oBAAoB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE1C,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAE5C,IAAI2B,KAAK,CAACf,UAAU,CAACkD,cAAc,CAAC,kBAAkB,CAAC,EAAE;UACvDnC,KAAK,CAACf,UAAU,CAAC,kBAAkB,CAAC,GAAGR,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC,kBAAkB,CAAC,EAAE,EAAE,CAAC;QAC3F;QAEA,IAAIe,KAAK,CAACf,UAAU,CAACkD,cAAc,CAAC,6BAA6B,CAAC,EAAE;UAClEnC,KAAK,CAACf,UAAU,CAAC,6BAA6B,CAAC,GAAGe,KAAK,CAACf,UAAU,CAAC,6BAA6B,CAAC,CAACE,KAAK,CAACnB,GAAG,CAAC;QAC9G;QAEA,IAAI,CAACF,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,oBAAoB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE1C,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,UAAU,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAClC,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGoC,UAAU,CAAChB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QACF,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAC5C,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAG,KAAK,CAAC0C,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QAEF,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAAC,WAAW,CAAC,EAAE;UAChDnC,KAAK,CAACf,UAAU,CAACwC,SAAS,GAAGtD,cAAc,CAAC6B,KAAK,CAACf,UAAU,CAACuC,SAAS,CAAC;QACzE;QAEA,IAAI,CAAC1D,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,8BAA8B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEpD,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,WAAW,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACvE,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGoC,UAAU,CAAChB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QACF,CAAC,qBAAqB,EAAE,kBAAkB,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACjE,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAG,KAAK,CAAC0C,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QACF,IAAI,CAACd,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,wBAAwB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE9C,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,aAAa,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACrC,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGoC,UAAU,CAAChB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QACF,IAAI,CAACd,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,4BAA4B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAElD,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,iBAAiB,EAAE,kBAAkB,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAC7D,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGH,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,EAAE,EAAE,CAAC;YAC3D,MAAMwD,MAAM,GAAGxD,GAAG,KAAK,kBAAkB,GAAG,QAAQ,GAAG,QAAQ;YAC/DoB,KAAK,CAACf,UAAU,CAACwC,SAAS,GAAGzB,KAAK,CAACf,UAAU,CAACwC,SAAS,IAAI,CAAC,CAAC;YAC7DzB,KAAK,CAACf,UAAU,CAACwC,SAAS,CAACW,MAAM,CAAC,GAAGpC,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC,CAAC;;YAE5D,OAAOoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC;UAC9B;QACF,CAAC,CAAC;QACF,IAAI,CAACd,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,gCAAgC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEtD,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,UAAU,EAAE,WAAW,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAC/C,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGH,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,EAAE,EAAE,CAAC;UAC7D;QACF,CAAC,CAAC;QACF,IAAI,CAACd,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,yBAAyB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE/C,IAAItC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACrB2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,CAAC,IAAI,EAAE,OAAO,CAAC,CAACqC,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACrC,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGX,MAAM,CAAC+B,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UACvD;QACF,CAAC,CAAC;QACF,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAChD,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAG,IAAIkD,IAAI,CAAC9B,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UACzD;QACF,CAAC,CAAC;QACF,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACtD,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGoC,UAAU,CAAChB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC3D;QACF,CAAC,CAAC;QACF,CAAC,aAAa,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UACrC,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAG,MAAM,CAAC0C,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UAC5D;QACF,CAAC,CAAC;QACF,CAAC,YAAY,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC8B,OAAO,CAAC,UAAU9B,GAAG,EAAE;UAChE,IAAIoB,KAAK,CAACf,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;YACxCoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAGoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAACyD,QAAQ,CAAC,EAAE,CAAC;UAC5D;QACF,CAAC,CAAC;QACF,MAAMC,sBAAsB,GAAG,sBAAsB;QAErD,KAAK,MAAM1D,GAAG,IAAIoB,KAAK,CAACf,UAAU,EAAE;UAClC,IAAI,CAACqD,sBAAsB,CAAChB,IAAI,CAAC1C,GAAG,CAAC,EAAE;YACrC;UACF;UAEA,MAAM2D,aAAa,GAAG,iBAAiB,CAACjB,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UACnE,MAAM4D,iBAAiB,GAAG,eAAe,CAAClB,IAAI,CAACtB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;UACrEoB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,GAAG2D,aAAa,GAAGvC,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAACyD,QAAQ,CAAC,EAAE,CAAC,GAAGG,iBAAiB,GAAGxB,UAAU,CAAChB,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC,GAAGX,MAAM,CAAC+B,KAAK,CAACf,UAAU,CAACL,GAAG,CAAC,CAAC;QACpK;QAEA,IAAI,CAACd,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,8BAA8B,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEpD,IAAItC,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAzC,KAAK,GAAG,uBAAuB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE7C,IAAItC,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAzC,KAAK,GAAG,gCAAgC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAEtD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,kCAAkC,CAACC,IAAI,CAACqC,OAAO,CAAC;MAExD,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAE5C,IAAI2B,KAAK,CAACf,UAAU,CAACsC,GAAG,EAAE;UACxBvB,KAAK,CAACG,GAAG,GAAGH,KAAK,CAACf,UAAU,CAACsC,GAAG;QAClC;QAEA,IAAIvB,KAAK,CAACf,UAAU,CAAC0C,SAAS,EAAE;UAC9B3B,KAAK,CAACf,UAAU,CAAC0C,SAAS,GAAGlD,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC0C,SAAS,EAAE,EAAE,CAAC;QACvE;QAEA,IAAI3B,KAAK,CAACf,UAAU,CAACyC,UAAU,EAAE;UAC/B1B,KAAK,CAACf,UAAU,CAACyC,UAAU,GAAGlC,eAAe,CAACQ,KAAK,CAACf,UAAU,CAACyC,UAAU,CAAC;QAC5E;QAEA,IAAI1B,KAAK,CAACf,UAAU,CAAC,mBAAmB,CAAC,EAAE;UACzCe,KAAK,CAACf,UAAU,CAAC,mBAAmB,CAAC,GAAGR,QAAQ,CAACuB,KAAK,CAACf,UAAU,CAAC,mBAAmB,CAAC,EAAE,EAAE,CAAC;QAC7F;QAEA,IAAIe,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,EAAE;UAClCe,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,GAAG+B,UAAU,CAAChB,KAAK,CAACf,UAAU,CAAC,YAAY,CAAC,CAAC;QAC7E;QAEA,IAAI,CAACnB,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF;MAEA3B,KAAK,GAAG,sBAAsB,CAACC,IAAI,CAACqC,OAAO,CAAC;MAE5C,IAAItC,KAAK,EAAE;QACT2B,KAAK,GAAG;UACNE,IAAI,EAAE,KAAK;UACXY,OAAO,EAAE;QACX,CAAC;QACDd,KAAK,CAACf,UAAU,GAAGD,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5C,IAAI,CAACP,OAAO,CAAC,MAAM,EAAEkC,KAAK,CAAC;QAC3B;MACF,CAAC,CAAC;;MAGF,IAAI,CAAClC,OAAO,CAAC,MAAM,EAAE;QACnBoC,IAAI,EAAE,KAAK;QACXvC,IAAI,EAAEgD,OAAO,CAACrB,KAAK,CAAC,CAAC;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGEmD,SAASA,CAAC;IACRC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC;EACF,CAAC,EAAE;IACD,IAAI,OAAOD,UAAU,KAAK,UAAU,EAAE;MACpCA,UAAU,GAAG7C,IAAI,IAAIA,IAAI;IAC3B;IAEA,IAAI,CAACF,aAAa,CAACnC,IAAI,CAACqC,IAAI,IAAI;MAC9B,MAAM1B,KAAK,GAAGqE,UAAU,CAACpE,IAAI,CAACyB,IAAI,CAAC;MAEnC,IAAI1B,KAAK,EAAE;QACT,IAAI,CAACP,OAAO,CAAC,MAAM,EAAE;UACnBoC,IAAI,EAAE,QAAQ;UACdvC,IAAI,EAAEiF,UAAU,CAAC7C,IAAI,CAAC;UACtB4C,UAAU;UACVE;QACF,CAAC,CAAC;QACF,OAAO,IAAI;MACb;IACF,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGEC,YAAYA,CAAC;IACXJ,UAAU;IACVK;EACF,CAAC,EAAE;IACD,MAAMC,KAAK,GAAGjD,IAAI,IAAI;MACpB,IAAI2C,UAAU,CAACpB,IAAI,CAACvB,IAAI,CAAC,EAAE;QACzB,OAAOgD,GAAG,CAAChD,IAAI,CAAC;MAClB;MAEA,OAAOA,IAAI;IACb,CAAC;IAED,IAAI,CAACD,UAAU,CAACpC,IAAI,CAACsF,KAAK,CAAC;EAC7B;AAEF;AAEA,MAAMC,SAAS,GAAGC,GAAG,IAAIA,GAAG,CAAClB,WAAW,CAAC,CAAC,CAACzC,OAAO,CAAC,QAAQ,EAAE4D,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;AAErF,MAAMC,aAAa,GAAG,SAAAA,CAAUpE,UAAU,EAAE;EAC1C,MAAMV,MAAM,GAAG,CAAC,CAAC;EACjB+E,MAAM,CAACC,IAAI,CAACtE,UAAU,CAAC,CAACyB,OAAO,CAAC,UAAU9B,GAAG,EAAE;IAC7CL,MAAM,CAAC0E,SAAS,CAACrE,GAAG,CAAC,CAAC,GAAGK,UAAU,CAACL,GAAG,CAAC;EAC1C,CAAC,CAAC;EACF,OAAOL,MAAM;AACf,CAAC,CAAC,CAAC;AACH;AACA;AACA;;AAGA,MAAMiF,WAAW,GAAG,SAAAA,CAAUC,QAAQ,EAAE;EACtC,MAAM;IACJC,aAAa;IACbC,cAAc;IACdC;EACF,CAAC,GAAGH,QAAQ;EAEZ,IAAI,CAACC,aAAa,EAAE;IAClB;EACF;EAEA,MAAMG,GAAG,GAAG,uBAAuB;EACnC,MAAMC,EAAE,GAAG,UAAU;EACrB,MAAMC,GAAG,GAAG,cAAc;EAC1B,MAAMC,iBAAiB,GAAGL,cAAc,IAAIA,cAAc,GAAG,CAAC;EAC9D,MAAMM,eAAe,GAAGL,kBAAkB,IAAIA,kBAAkB,GAAG,CAAC;EAEpE,IAAID,cAAc,IAAI,CAACD,aAAa,CAACvB,cAAc,CAAC2B,EAAE,CAAC,EAAE;IACvDJ,aAAa,CAACI,EAAE,CAAC,GAAGE,iBAAiB;IACrC,IAAI,CAAClG,OAAO,CAAC,MAAM,EAAE;MACnBoG,OAAO,EAAE,GAAGL,GAAG,gDAAgDG,iBAAiB;IAClF,CAAC,CAAC;EACJ;EAEA,IAAIA,iBAAiB,IAAIN,aAAa,CAACI,EAAE,CAAC,GAAGE,iBAAiB,EAAE;IAC9D,IAAI,CAAClG,OAAO,CAAC,MAAM,EAAE;MACnBoG,OAAO,EAAE,GAAGL,GAAG,wBAAwBH,aAAa,CAACI,EAAE,CAAC,4BAA4BE,iBAAiB;IACvG,CAAC,CAAC;IACFN,aAAa,CAACI,EAAE,CAAC,GAAGE,iBAAiB;EACvC,CAAC,CAAC;;EAGF,IAAIJ,kBAAkB,IAAI,CAACF,aAAa,CAACvB,cAAc,CAAC4B,GAAG,CAAC,EAAE;IAC5DL,aAAa,CAACK,GAAG,CAAC,GAAGH,kBAAkB,GAAG,CAAC;IAC3C,IAAI,CAAC9F,OAAO,CAAC,MAAM,EAAE;MACnBoG,OAAO,EAAE,GAAGL,GAAG,yDAAyDH,aAAa,CAACK,GAAG,CAAC;IAC5F,CAAC,CAAC;EACJ,CAAC,CAAC;;EAGF,IAAIH,kBAAkB,IAAIF,aAAa,CAACK,GAAG,CAAC,GAAGE,eAAe,EAAE;IAC9D,IAAI,CAACnG,OAAO,CAAC,MAAM,EAAE;MACnBoG,OAAO,EAAE,GAAGL,GAAG,6BAA6BH,aAAa,CAACK,GAAG,CAAC,gCAAgCE,eAAe;IAC/G,CAAC,CAAC;IACFP,aAAa,CAACK,GAAG,CAAC,GAAGE,eAAe;EACtC;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAME,MAAM,SAAS/G,MAAM,CAAC;EAC1BI,WAAWA,CAAC4G,IAAI,GAAG,CAAC,CAAC,EAAE;IACrB,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,UAAU,GAAG,IAAI9G,UAAU,CAAC,CAAC;IAClC,IAAI,CAAC+G,WAAW,GAAG,IAAI1E,WAAW,CAAC,CAAC;IACpC,IAAI,CAACyE,UAAU,CAACE,IAAI,CAAC,IAAI,CAACD,WAAW,CAAC;IACtC,IAAI,CAACE,eAAe,GAAGJ,IAAI,CAACI,eAAe,IAAI,CAAC,CAAC;IACjD,IAAI,CAACC,MAAM,GAAG,IAAIC,GAAG,CAACN,IAAI,CAACjE,GAAG,EAAE,eAAe,CAAC,CAACwE,YAAY;IAC7D,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B;;IAEA,MAAMC,IAAI,GAAG,IAAI;IACjB;;IAEA,MAAMC,IAAI,GAAG,EAAE;IACf,IAAIC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;;IAErB,IAAIC,UAAU,CAAC,CAAC;;IAEhB,IAAIpG,GAAG;IACP,IAAIqG,QAAQ,GAAG,KAAK;IAEpB,MAAMC,IAAI,GAAG,SAAAA,CAAA,EAAY,CAAC,CAAC;IAE3B,MAAMC,kBAAkB,GAAG;MACzB,OAAO,EAAE,CAAC,CAAC;MACX,OAAO,EAAE,CAAC,CAAC;MACX,iBAAiB,EAAE,CAAC,CAAC;MACrB,WAAW,EAAE,CAAC;IAChB,CAAC,CAAC,CAAC;IACH;;IAEA,MAAMC,YAAY,GAAG,+CAA+C,CAAC,CAAC;;IAEtE,IAAIC,eAAe,GAAG,CAAC,CAAC,CAAC;;IAEzB,IAAI,CAAC5B,QAAQ,GAAG;MACd6B,UAAU,EAAE,IAAI;MAChBC,mBAAmB,EAAE,EAAE;MACvBC,UAAU,EAAE,EAAE;MACdC,eAAe,EAAE,EAAE;MACnBC,QAAQ,EAAE;IACZ,CAAC,CAAC,CAAC;IACH;IACA;;IAEA,IAAIC,gBAAgB,GAAG,CAAC,CAAC,CAAC;;IAE1B,IAAIC,oBAAoB,GAAG,CAAC;IAC5B,MAAMC,aAAa,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,EAAE,CAAC,KAAK,EAAE,MAAM;MACnB;MACA;MACA,IAAIf,UAAU,CAAC5E,GAAG,IAAI,CAAC4E,UAAU,CAACgB,KAAK,IAAI,CAAChB,UAAU,CAACiB,YAAY,EAAE;QACnE;MACF;MAEA,IAAI,CAACjB,UAAU,CAAChC,GAAG,IAAIiC,UAAU,EAAE;QACjCD,UAAU,CAAChC,GAAG,GAAGiC,UAAU;MAC7B;MAEA,IAAI,CAACD,UAAU,CAACnG,GAAG,IAAIA,GAAG,EAAE;QAC1BmG,UAAU,CAACnG,GAAG,GAAGA,GAAG;MACtB;MAEA,IAAI,CAACmG,UAAU,CAACkB,QAAQ,IAAI,OAAOZ,eAAe,KAAK,QAAQ,EAAE;QAC/DN,UAAU,CAACkB,QAAQ,GAAGZ,eAAe;MACvC;MAEA,IAAI,CAAC5B,QAAQ,CAACyC,cAAc,GAAGnB,UAAU;IAC3C,CAAC,CAAC,CAAC,CAAC;;IAEJ,IAAI,CAACT,WAAW,CAACwB,EAAE,CAAC,MAAM,EAAE,UAAUK,KAAK,EAAE;MAC3C,IAAIC,UAAU;MACd,IAAIC,SAAS,CAAC,CAAC;;MAEf,IAAIxB,IAAI,CAACpB,QAAQ,CAAC6C,WAAW,EAAE;QAC7B,KAAK,MAAMC,GAAG,IAAI1B,IAAI,CAACpB,QAAQ,CAAC6C,WAAW,EAAE;UAC3C,IAAIH,KAAK,CAAChG,GAAG,EAAE;YACbgG,KAAK,CAAChG,GAAG,GAAGgG,KAAK,CAAChG,GAAG,CAACZ,OAAO,CAAC,KAAKgH,GAAG,GAAG,EAAE1B,IAAI,CAACpB,QAAQ,CAAC6C,WAAW,CAACC,GAAG,CAAC,CAAC;UAC5E;UAEA,IAAIJ,KAAK,CAAClH,UAAU,EAAE;YACpB,KAAK,MAAMI,IAAI,IAAI8G,KAAK,CAAClH,UAAU,EAAE;cACnC,IAAI,OAAOkH,KAAK,CAAClH,UAAU,CAACI,IAAI,CAAC,KAAK,QAAQ,EAAE;gBAC9C8G,KAAK,CAAClH,UAAU,CAACI,IAAI,CAAC,GAAG8G,KAAK,CAAClH,UAAU,CAACI,IAAI,CAAC,CAACE,OAAO,CAAC,KAAKgH,GAAG,GAAG,EAAE1B,IAAI,CAACpB,QAAQ,CAAC6C,WAAW,CAACC,GAAG,CAAC,CAAC;cACtG;YACF;UACF;QACF;MACF;MAEA,CAAC;QACC1C,GAAGA,CAAA,EAAG;UACJ;UACA,CAAE;YACA3C,OAAOA,CAAA,EAAG;cACR,IAAIiF,KAAK,CAACjF,OAAO,EAAE;gBACjB,IAAI,CAACuC,QAAQ,CAACvC,OAAO,GAAGiF,KAAK,CAACjF,OAAO;cACvC;YACF,CAAC;YAED,aAAasF,CAAA,EAAG;cACd,IAAI,CAAC/C,QAAQ,CAAC6B,UAAU,GAAGa,KAAK,CAAC9E,OAAO;cAExC,IAAI,EAAE,SAAS,IAAI8E,KAAK,CAAC,EAAE;gBACzB,IAAI,CAACrI,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF,IAAI,CAACT,QAAQ,CAAC6B,UAAU,GAAG,IAAI;cACjC;YACF,CAAC;YAED7D,SAASA,CAAA,EAAG;cACV,MAAMA,SAAS,GAAG,CAAC,CAAC;cAEpB,IAAI,QAAQ,IAAI0E,KAAK,EAAE;gBACrBpB,UAAU,CAACtD,SAAS,GAAGA,SAAS;gBAChCA,SAAS,CAACjD,MAAM,GAAG2H,KAAK,CAAC3H,MAAM;gBAE/B,IAAI,EAAE,QAAQ,IAAI2H,KAAK,CAAC,EAAE;kBACxB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;kBACkBA,KAAK,CAACzH,MAAM,GAAGiH,gBAAgB;gBACjC;cACF;cAEA,IAAI,QAAQ,IAAIQ,KAAK,EAAE;gBACrBpB,UAAU,CAACtD,SAAS,GAAGA,SAAS;gBAChCA,SAAS,CAAC/C,MAAM,GAAGyH,KAAK,CAACzH,MAAM;cACjC;cAEAiH,gBAAgB,GAAGlE,SAAS,CAAC/C,MAAM,GAAG+C,SAAS,CAACjD,MAAM;YACxD,CAAC;YAEDiI,OAAOA,CAAA,EAAG;cACR,IAAI,CAAChD,QAAQ,CAACiD,OAAO,GAAG,IAAI;YAC9B,CAAC;YAEDC,GAAGA,CAAA,EAAG;cACJ,IAAI,EAAE,eAAe,IAAI,IAAI,CAAClD,QAAQ,CAAC,EAAE;gBACvC,IAAI,CAACA,QAAQ,CAACmD,aAAa,GAAG,CAAC;gBAC/B,IAAI,CAAC9I,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAI,EAAE,uBAAuB,IAAI,IAAI,CAACT,QAAQ,CAAC,EAAE;gBAC/C,IAAI,CAACA,QAAQ,CAACoD,qBAAqB,GAAG,CAAC;gBACvC,IAAI,CAAC/I,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAIiC,KAAK,CAAClF,KAAK,EAAE;gBACf8D,UAAU,CAAC9D,KAAK,GAAGkF,KAAK,CAAClF,KAAK;cAChC;cAEA,IAAIkF,KAAK,CAACpF,QAAQ,GAAG,CAAC,EAAE;gBACtBgE,UAAU,CAAChE,QAAQ,GAAGoF,KAAK,CAACpF,QAAQ;cACtC;cAEA,IAAIoF,KAAK,CAACpF,QAAQ,KAAK,CAAC,EAAE;gBACxBgE,UAAU,CAAChE,QAAQ,GAAG,IAAI;gBAC1B,IAAI,CAACjD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAI,CAACT,QAAQ,CAACiC,QAAQ,GAAGZ,IAAI;YAC/B,CAAC;YAEDlG,GAAGA,CAAA,EAAG;cACJ,IAAI,CAACuH,KAAK,CAAClH,UAAU,EAAE;gBACrB,IAAI,CAACnB,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF;cACF,CAAC,CAAC;;cAGF,IAAIiC,KAAK,CAAClH,UAAU,CAAC6H,MAAM,KAAK,MAAM,EAAE;gBACtClI,GAAG,GAAG,IAAI;gBACV;cACF;cAEA,IAAI,CAACuH,KAAK,CAAClH,UAAU,CAACsC,GAAG,EAAE;gBACzB,IAAI,CAACzD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF;cACF;cAEA,IAAIiC,KAAK,CAAClH,UAAU,CAAC8H,SAAS,KAAK,gCAAgC,EAAE;gBACnE,IAAI,CAACtD,QAAQ,CAACuD,iBAAiB,GAAG,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,IAAI,CAAC,CAAC,CAAC,CAAC;;gBAEzE,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,CAAC,mBAAmB,CAAC,GAAG;kBACrD/H,UAAU,EAAEkH,KAAK,CAAClH;gBACpB,CAAC;gBACD;cACF;cAEA,IAAIkH,KAAK,CAAClH,UAAU,CAAC8H,SAAS,KAAK,yBAAyB,EAAE;gBAC5D,IAAI,CAACtD,QAAQ,CAACuD,iBAAiB,GAAG,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,IAAI,CAAC,CAAC,CAAC,CAAC;;gBAEzE,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,CAAC,yBAAyB,CAAC,GAAG;kBAC3D7G,GAAG,EAAEgG,KAAK,CAAClH,UAAU,CAACsC;gBACxB,CAAC;gBACD;cACF,CAAC,CAAC;cACF;;cAGA,IAAI4E,KAAK,CAAClH,UAAU,CAAC8H,SAAS,KAAK3B,YAAY,EAAE;gBAC/C,MAAM6B,aAAa,GAAG,CAAC,YAAY,EAAE,gBAAgB,EAAE,iBAAiB,CAAC;gBAEzE,IAAIA,aAAa,CAACpJ,OAAO,CAACsI,KAAK,CAAClH,UAAU,CAAC6H,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;kBACzD,IAAI,CAAChJ,OAAO,CAAC,MAAM,EAAE;oBACnBoG,OAAO,EAAE;kBACX,CAAC,CAAC;kBACF;gBACF;gBAEA,IAAIiC,KAAK,CAAClH,UAAU,CAAC6H,MAAM,KAAK,iBAAiB,EAAE;kBACjD,IAAI,CAAChJ,OAAO,CAAC,MAAM,EAAE;oBACnBoG,OAAO,EAAE;kBACX,CAAC,CAAC;gBACJ;gBAEA,IAAIiC,KAAK,CAAClH,UAAU,CAACsC,GAAG,CAACxD,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,yBAAyB,EAAE;kBACvE,IAAI,CAACD,OAAO,CAAC,MAAM,EAAE;oBACnBoG,OAAO,EAAE;kBACX,CAAC,CAAC;kBACF;gBACF;gBAEA,IAAI,EAAEiC,KAAK,CAAClH,UAAU,CAACiI,KAAK,IAAIf,KAAK,CAAClH,UAAU,CAACiI,KAAK,CAACnJ,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE;kBAChF,IAAI,CAACD,OAAO,CAAC,MAAM,EAAE;oBACnBoG,OAAO,EAAE;kBACX,CAAC,CAAC;kBACF;gBACF,CAAC,CAAC;gBACF;;gBAGA,IAAI,CAACT,QAAQ,CAACuD,iBAAiB,GAAG,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,IAAI,CAAC,CAAC;gBACvE,IAAI,CAACvD,QAAQ,CAACuD,iBAAiB,CAAC,oBAAoB,CAAC,GAAG;kBACtD/H,UAAU,EAAE;oBACVkI,WAAW,EAAEhB,KAAK,CAAClH,UAAU,CAAC8H,SAAS;oBACvC;oBACAK,KAAK,EAAEjB,KAAK,CAAClH,UAAU,CAACiI,KAAK,CAACnJ,SAAS,CAAC,CAAC;kBAC3C,CAAC;kBACD;kBACAsJ,IAAI,EAAE/J,qBAAqB,CAAC6I,KAAK,CAAClH,UAAU,CAACsC,GAAG,CAACpC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAChE,CAAC;gBACD;cACF;cAEA,IAAI,CAACgH,KAAK,CAAClH,UAAU,CAAC6H,MAAM,EAAE;gBAC5B,IAAI,CAAChJ,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ,CAAC,CAAC;;cAGFtF,GAAG,GAAG;gBACJ0I,MAAM,EAAEnB,KAAK,CAAClH,UAAU,CAAC6H,MAAM,IAAI,SAAS;gBAC5C3G,GAAG,EAAEgG,KAAK,CAAClH,UAAU,CAACsC;cACxB,CAAC;cAED,IAAI,OAAO4E,KAAK,CAAClH,UAAU,CAAC8C,EAAE,KAAK,WAAW,EAAE;gBAC9CnD,GAAG,CAAC2I,EAAE,GAAGpB,KAAK,CAAClH,UAAU,CAAC8C,EAAE;cAC9B;YACF,CAAC;YAED,gBAAgByF,CAAA,EAAG;cACjB,IAAI,CAACC,QAAQ,CAACtB,KAAK,CAAChF,MAAM,CAAC,EAAE;gBAC3B,IAAI,CAACrD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE,mCAAmC,GAAGiC,KAAK,CAAChF;gBACvD,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAACsC,QAAQ,CAACmD,aAAa,GAAGT,KAAK,CAAChF,MAAM;YAC5C,CAAC;YAED,wBAAwBuG,CAAA,EAAG;cACzB,IAAI,CAACD,QAAQ,CAACtB,KAAK,CAAChF,MAAM,CAAC,EAAE;gBAC3B,IAAI,CAACrD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE,2CAA2C,GAAGiC,KAAK,CAAChF;gBAC/D,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAACsC,QAAQ,CAACoD,qBAAqB,GAAGV,KAAK,CAAChF,MAAM;cAClDkE,eAAe,GAAGc,KAAK,CAAChF,MAAM;YAChC,CAAC;YAED,eAAewG,CAAA,EAAG;cAChB,IAAI,CAAC,WAAW,CAACrG,IAAI,CAAC6E,KAAK,CAAC/E,YAAY,CAAC,EAAE;gBACzC,IAAI,CAACtD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE,kCAAkC,GAAGiC,KAAK,CAACyB;gBACtD,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAACnE,QAAQ,CAACrC,YAAY,GAAG+E,KAAK,CAAC/E,YAAY;YACjD,CAAC;YAED2B,GAAGA,CAAA,EAAG;cACJiC,UAAU,GAAG,CAAC,CAAC;cAEf,IAAImB,KAAK,CAAChG,GAAG,EAAE;gBACb6E,UAAU,CAAC7E,GAAG,GAAGgG,KAAK,CAAChG,GAAG;cAC5B;cAEA,IAAIgG,KAAK,CAAC1E,SAAS,EAAE;gBACnBuD,UAAU,CAACvD,SAAS,GAAG0E,KAAK,CAAC1E,SAAS;cACxC;cAEA,IAAI7C,GAAG,EAAE;gBACPoG,UAAU,CAACpG,GAAG,GAAGA,GAAG;cACtB;YACF,CAAC;YAED,YAAYiJ,CAAA,EAAG;cACb,IAAI,CAACpE,QAAQ,CAACqE,SAAS,GAAGhD,IAAI;cAC9B,IAAI,CAACrB,QAAQ,CAACsE,WAAW,GAAG,IAAI,CAACtE,QAAQ,CAACsE,WAAW,IAAI5C,kBAAkB;cAE3E,IAAI,CAACgB,KAAK,CAAClH,UAAU,EAAE;gBACrB,IAAI,CAACnB,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAACa,UAAU,CAAC9F,UAAU,EAAE;gBAC1B8F,UAAU,CAAC9F,UAAU,GAAG,CAAC,CAAC;cAC5B;cAEA5B,QAAQ,CAAC0H,UAAU,CAAC9F,UAAU,EAAEkH,KAAK,CAAClH,UAAU,CAAC;YACnD,CAAC;YAED+I,KAAKA,CAAA,EAAG;cACN,IAAI,CAACvE,QAAQ,CAACsE,WAAW,GAAG,IAAI,CAACtE,QAAQ,CAACsE,WAAW,IAAI5C,kBAAkB;cAE3E,IAAI,EAAEgB,KAAK,CAAClH,UAAU,IAAIkH,KAAK,CAAClH,UAAU,CAACgJ,IAAI,IAAI9B,KAAK,CAAClH,UAAU,CAAC,UAAU,CAAC,IAAIkH,KAAK,CAAClH,UAAU,CAACiJ,IAAI,CAAC,EAAE;gBACzG,IAAI,CAACpK,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF;cACF,CAAC,CAAC;;cAGF,MAAMiE,cAAc,GAAG,IAAI,CAAC1E,QAAQ,CAACsE,WAAW,CAAC5B,KAAK,CAAClH,UAAU,CAACgJ,IAAI,CAAC;cACvEE,cAAc,CAAChC,KAAK,CAAClH,UAAU,CAAC,UAAU,CAAC,CAAC,GAAGkJ,cAAc,CAAChC,KAAK,CAAClH,UAAU,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC;cACjGmH,UAAU,GAAG+B,cAAc,CAAChC,KAAK,CAAClH,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;;cAE3DoH,SAAS,GAAG;gBACV+B,OAAO,EAAE,MAAM,CAAC9G,IAAI,CAAC6E,KAAK,CAAClH,UAAU,CAACoJ,OAAO;cAC/C,CAAC;cAED,IAAIhC,SAAS,CAAC+B,OAAO,EAAE;gBACrB/B,SAAS,CAACiC,UAAU,GAAG,IAAI;cAC7B,CAAC,MAAM;gBACLjC,SAAS,CAACiC,UAAU,GAAG,MAAM,CAAChH,IAAI,CAAC6E,KAAK,CAAClH,UAAU,CAACsJ,UAAU,CAAC;cACjE;cAEA,IAAIpC,KAAK,CAAClH,UAAU,CAACuJ,QAAQ,EAAE;gBAC7BnC,SAAS,CAACoC,QAAQ,GAAGtC,KAAK,CAAClH,UAAU,CAACuJ,QAAQ;cAChD;cAEA,IAAIrC,KAAK,CAAClH,UAAU,CAACsC,GAAG,EAAE;gBACxB8E,SAAS,CAAClG,GAAG,GAAGgG,KAAK,CAAClH,UAAU,CAACsC,GAAG;cACtC;cAEA,IAAI4E,KAAK,CAAClH,UAAU,CAAC,aAAa,CAAC,EAAE;gBACnCoH,SAAS,CAACqC,UAAU,GAAGvC,KAAK,CAAClH,UAAU,CAAC,aAAa,CAAC;cACxD;cAEA,IAAIkH,KAAK,CAAClH,UAAU,CAAC0J,eAAe,EAAE;gBACpCtC,SAAS,CAACuC,eAAe,GAAGzC,KAAK,CAAClH,UAAU,CAAC0J,eAAe;cAC9D;cAEA,IAAIxC,KAAK,CAAClH,UAAU,CAAC4J,MAAM,EAAE;gBAC3BxC,SAAS,CAACyC,MAAM,GAAG,MAAM,CAACxH,IAAI,CAAC6E,KAAK,CAAClH,UAAU,CAAC4J,MAAM,CAAC;cACzD,CAAC,CAAC;;cAGFzC,UAAU,CAACD,KAAK,CAAClH,UAAU,CAACiJ,IAAI,CAAC,GAAG7B,SAAS;YAC/C,CAAC;YAED0C,aAAaA,CAAA,EAAG;cACd1D,eAAe,IAAI,CAAC;cACpBN,UAAU,CAACgE,aAAa,GAAG,IAAI;cAC/B,IAAI,CAACtF,QAAQ,CAAC8B,mBAAmB,CAAC7H,IAAI,CAACoH,IAAI,CAACtG,MAAM,CAAC;YACrD,CAAC;YAED,mBAAmBwK,CAAA,EAAG;cACpB,IAAI,OAAO,IAAI,CAACvF,QAAQ,CAAC7B,cAAc,KAAK,WAAW,EAAE;gBACvD;gBACA;gBACA;gBACA;gBACA,IAAI,CAAC6B,QAAQ,CAAC7B,cAAc,GAAGuE,KAAK,CAACvE,cAAc;gBACnD,IAAI,CAAC6B,QAAQ,CAAC5B,cAAc,GAAGsE,KAAK,CAACtE,cAAc;cACrD;cAEAkD,UAAU,CAACnD,cAAc,GAAGuE,KAAK,CAACvE,cAAc;cAChDmD,UAAU,CAAClD,cAAc,GAAGsE,KAAK,CAACtE,cAAc;cAChD,MAAM;gBACJ+C;cACF,CAAC,GAAG,IAAI;cACR,IAAI,CAACA,mBAAmB,GAAG,IAAI9C,IAAI,CAACqE,KAAK,CAACvE,cAAc,CAAC,CAACqH,OAAO,CAAC,CAAC,CAAC,CAAC;cACrE;;cAEA,IAAIrE,mBAAmB,KAAK,IAAI,EAAE;gBAChC;gBACA;gBACA;gBACA,IAAI,CAACnB,QAAQ,CAACiC,QAAQ,CAACwD,WAAW,CAAC,CAACC,eAAe,EAAEtG,OAAO,KAAK;kBAC/DA,OAAO,CAACsG,eAAe,GAAGA,eAAe,GAAGtG,OAAO,CAAC9B,QAAQ,GAAG,IAAI;kBACnE,OAAO8B,OAAO,CAACsG,eAAe;gBAChC,CAAC,EAAE,IAAI,CAACvE,mBAAmB,CAAC;cAC9B;YACF,CAAC;YAEDwE,cAAcA,CAAA,EAAG;cACf,IAAI,CAAC3B,QAAQ,CAACtB,KAAK,CAACpF,QAAQ,CAAC,IAAIoF,KAAK,CAACpF,QAAQ,GAAG,CAAC,EAAE;gBACnD,IAAI,CAACjD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE,oCAAoC,GAAGiC,KAAK,CAACpF;gBACxD,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAAC0C,QAAQ,CAACE,cAAc,GAAGwC,KAAK,CAACpF,QAAQ;cAC7CyC,WAAW,CAAC5C,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC6C,QAAQ,CAAC;YACvC,CAAC;YAED4F,KAAKA,CAAA,EAAG;cACN,IAAI,CAAClD,KAAK,CAAClH,UAAU,IAAIqK,KAAK,CAACnD,KAAK,CAAClH,UAAU,CAAC,aAAa,CAAC,CAAC,EAAE;gBAC/D,IAAI,CAACnB,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;gBACF;cACF;cAEA,IAAI,CAACT,QAAQ,CAAC4F,KAAK,GAAG;gBACpBE,UAAU,EAAEpD,KAAK,CAAClH,UAAU,CAAC,aAAa,CAAC;gBAC3CuK,OAAO,EAAErD,KAAK,CAAClH,UAAU,CAACiD;cAC5B,CAAC;YACH,CAAC;YAED,SAASuH,CAAA,EAAG;cACV1E,UAAU,CAAC2E,MAAM,GAAGvD,KAAK,CAACxI,IAAI;YAChC,CAAC;YAED,cAAcgM,CAAA,EAAG;cACf5E,UAAU,CAAC6E,UAAU,GAAGzD,KAAK,CAACxI,IAAI;YACpC,CAAC;YAED,QAAQkM,CAAA,EAAG;cACT9E,UAAU,CAAC+E,KAAK,GAAG3D,KAAK,CAACxI,IAAI;YAC/B,CAAC;YAED,MAAMoM,CAAA,EAAG;cACP,IAAI,CAACtG,QAAQ,CAACsG,IAAI,GAAG1G,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cACpD,IAAI,CAAC+K,wBAAwB,CAAC,aAAa,EAAE7D,KAAK,CAAClH,UAAU,EAAE,CAAC,kBAAkB,CAAC,CAAC;YACtF,CAAC;YAED,MAAMgL,CAAA,EAAG;cACPhF,QAAQ,GAAG,IAAI,CAAC,CAAC;;cAEjB,MAAMiF,YAAY,GAAG,IAAI,CAACzG,QAAQ,CAACiC,QAAQ,CAAClH,MAAM;cAClD,MAAMyL,IAAI,GAAG5G,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cAC5C8F,UAAU,CAACgB,KAAK,GAAGhB,UAAU,CAACgB,KAAK,IAAI,EAAE;cACzChB,UAAU,CAACgB,KAAK,CAACrI,IAAI,CAACuM,IAAI,CAAC;cAE3B,IAAIA,IAAI,CAACxI,SAAS,EAAE;gBAClB,IAAI,CAACwI,IAAI,CAACxI,SAAS,CAACU,cAAc,CAAC,QAAQ,CAAC,EAAE;kBAC5C8H,IAAI,CAACxI,SAAS,CAAC/C,MAAM,GAAGkH,oBAAoB;gBAC9C;gBAEAA,oBAAoB,GAAGqE,IAAI,CAACxI,SAAS,CAAC/C,MAAM,GAAGuL,IAAI,CAACxI,SAAS,CAACjD,MAAM;cACtE;cAEA,MAAM2L,SAAS,GAAGpF,UAAU,CAACgB,KAAK,CAACvH,MAAM,GAAG,CAAC;cAC7C,IAAI,CAACwL,wBAAwB,CAAC,gBAAgBG,SAAS,iBAAiBD,YAAY,EAAE,EAAE/D,KAAK,CAAClH,UAAU,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;cAE9H,IAAI,IAAI,CAACwE,QAAQ,CAAC2G,gBAAgB,EAAE;gBAClC,IAAI,CAAC3G,QAAQ,CAAC2G,gBAAgB,CAAC1J,OAAO,CAAC,CAAC2J,CAAC,EAAEjL,CAAC,KAAK;kBAC/C,IAAI,CAACiL,CAAC,CAAClI,cAAc,CAAC,UAAU,CAAC,EAAE;oBACjC,IAAI,CAACrE,OAAO,CAAC,MAAM,EAAE;sBACnBoG,OAAO,EAAE,4BAA4B9E,CAAC;oBACxC,CAAC,CAAC;kBACJ;gBACF,CAAC,CAAC;cACJ;YACF,CAAC;YAED,gBAAgBkL,CAAA,EAAG;cACjB,MAAMpL,KAAK,GAAG,IAAI,CAACuE,QAAQ,CAACC,aAAa,GAAGL,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cAE3E,IAAI,CAACC,KAAK,CAACiD,cAAc,CAAC,gBAAgB,CAAC,EAAE;gBAC3CjD,KAAK,CAACqL,cAAc,GAAG,KAAK;gBAC5B,IAAI,CAACzM,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEAV,WAAW,CAAC5C,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC6C,QAAQ,CAAC;cAErC,IAAIvE,KAAK,CAACsL,iBAAiB,IAAI,CAACtL,KAAK,CAACiD,cAAc,CAAC,cAAc,CAAC,EAAE;gBACpE,IAAI,CAACrE,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;YACF,CAAC;YAED,cAAcuG,CAAA,EAAG;cACf;cACA,MAAMP,YAAY,GAAG,IAAI,CAACzG,QAAQ,CAACiC,QAAQ,CAAClH,MAAM;cAClD,MAAMkM,IAAI,GAAGrH,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cAC5C,MAAM0L,MAAM,GAAGD,IAAI,CAACxK,IAAI,IAAIwK,IAAI,CAACxK,IAAI,KAAK,MAAM;cAChD6E,UAAU,CAACiB,YAAY,GAAGjB,UAAU,CAACiB,YAAY,IAAI,EAAE;cACvDjB,UAAU,CAACiB,YAAY,CAACtI,IAAI,CAACgN,IAAI,CAAC;cAElC,IAAIA,IAAI,CAACjJ,SAAS,EAAE;gBAClB,IAAI,CAACiJ,IAAI,CAACjJ,SAAS,CAACU,cAAc,CAAC,QAAQ,CAAC,EAAE;kBAC5C;kBACAuI,IAAI,CAACjJ,SAAS,CAAC/C,MAAM,GAAGiM,MAAM,GAAG/E,oBAAoB,GAAG,CAAC;kBAEzD,IAAI+E,MAAM,EAAE;oBACV/E,oBAAoB,GAAG8E,IAAI,CAACjJ,SAAS,CAAC/C,MAAM,GAAGgM,IAAI,CAACjJ,SAAS,CAACjD,MAAM;kBACtE;gBACF;cACF;cAEA,MAAMoM,KAAK,GAAG7F,UAAU,CAACiB,YAAY,CAACxH,MAAM,GAAG,CAAC;cAChD,IAAI,CAACwL,wBAAwB,CAAC,wBAAwBY,KAAK,iBAAiBV,YAAY,EAAE,EAAE/D,KAAK,CAAClH,UAAU,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;cAE9H,IAAI,CAACyL,IAAI,CAACxK,IAAI,EAAE;gBACd;cACF,CAAC,CAAC;cACF;;cAGA,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2F,UAAU,CAACiB,YAAY,CAACxH,MAAM,GAAG,CAAC,EAAEY,CAAC,EAAE,EAAE;gBAC3D,MAAMyL,SAAS,GAAG9F,UAAU,CAACiB,YAAY,CAAC5G,CAAC,CAAC;gBAE5C,IAAI,CAACyL,SAAS,CAAC3K,IAAI,EAAE;kBACnB;gBACF;gBAEA,IAAI2K,SAAS,CAAC3K,IAAI,KAAKwK,IAAI,CAACxK,IAAI,EAAE;kBAChC,IAAI,CAACpC,OAAO,CAAC,MAAM,EAAE;oBACnBoG,OAAO,EAAE,wBAAwB0G,KAAK,iBAAiBV,YAAY,sBAAsBQ,IAAI,CAACxK,IAAI,qBAAqBd,CAAC;kBAC1H,CAAC,CAAC;gBACJ;cACF;YACF,CAAC;YAED,kBAAkB0L,CAAA,EAAG;cACnB,MAAMC,MAAM,GAAG1H,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cAC9C,IAAI,CAACwE,QAAQ,CAAC2G,gBAAgB,GAAG,IAAI,CAAC3G,QAAQ,CAAC2G,gBAAgB,IAAI,EAAE;cACrE,IAAI,CAAC3G,QAAQ,CAAC2G,gBAAgB,CAAC1M,IAAI,CAACqN,MAAM,CAAC;cAC3C,MAAMH,KAAK,GAAG,IAAI,CAACnH,QAAQ,CAAC2G,gBAAgB,CAAC5L,MAAM,GAAG,CAAC;cACvD,MAAMwM,QAAQ,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC;cAEpC,IAAI/F,QAAQ,EAAE;gBACZ+F,QAAQ,CAACtN,IAAI,CAAC,WAAW,CAAC;cAC5B;cAEA,IAAI,CAACsM,wBAAwB,CAAC,4BAA4BY,KAAK,EAAE,EAAEzE,KAAK,CAAClH,UAAU,EAAE+L,QAAQ,CAAC;YAChG,CAAC;YAED,UAAUC,CAAA,EAAG;cACX,IAAI,CAACxH,QAAQ,CAACyH,OAAO,GAAG7H,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cACvD,IAAI,CAAC+K,wBAAwB,CAAC,iBAAiB,EAAE7D,KAAK,CAAClH,UAAU,EAAE,CAAC,aAAa,CAAC,CAAC;cAEnF,IAAI,IAAI,CAACwE,QAAQ,CAACyH,OAAO,CAACC,UAAU,EAAE;gBACpC,IAAI,CAAC1H,QAAQ,CAACG,kBAAkB,GAAG,IAAI,CAACH,QAAQ,CAACyH,OAAO,CAACC,UAAU;cACrE;cAEA3H,WAAW,CAAC5C,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC6C,QAAQ,CAAC;YACvC,CAAC;YAED,WAAW2H,CAAA,EAAG;cACZ,IAAI,CAAC3H,QAAQ,CAAC+B,UAAU,CAAC9H,IAAI,CAAC2F,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC,CAAC;cAC9D,MAAM2L,KAAK,GAAG,IAAI,CAACnH,QAAQ,CAAC+B,UAAU,CAAChH,MAAM,GAAG,CAAC;cACjD,IAAI,CAACwL,wBAAwB,CAAC,qBAAqBY,KAAK,EAAE,EAAEzE,KAAK,CAAClH,UAAU,EAAE,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;cACnG,MAAMoM,SAAS,GAAG,IAAI,CAAC5H,QAAQ,CAAC+B,UAAU,CAACoF,KAAK,CAAC;cAEjD,IAAIS,SAAS,CAACC,OAAO,IAAID,SAAS,CAACE,SAAS,IAAI,IAAIzJ,IAAI,CAACuJ,SAAS,CAACC,OAAO,CAAC,GAAG,IAAIxJ,IAAI,CAACuJ,SAAS,CAACE,SAAS,CAAC,EAAE;gBAC3G,IAAI,CAACzN,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAImH,SAAS,CAACtK,QAAQ,IAAIsK,SAAS,CAACtK,QAAQ,GAAG,CAAC,EAAE;gBAChD,IAAI,CAACjD,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAImH,SAAS,CAACG,eAAe,IAAIH,SAAS,CAACG,eAAe,GAAG,CAAC,EAAE;gBAC9D,IAAI,CAAC1N,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,MAAMuH,YAAY,GAAG,CAAC,CAACJ,SAAS,CAACK,SAAS;cAE1C,IAAID,YAAY,IAAI,CAACJ,SAAS,CAACM,KAAK,EAAE;gBACpC,IAAI,CAAC7N,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAIuH,YAAY,KAAKJ,SAAS,CAACtK,QAAQ,IAAIsK,SAAS,CAACC,OAAO,CAAC,EAAE;gBAC7D,IAAI,CAACxN,OAAO,CAAC,MAAM,EAAE;kBACnBoG,OAAO,EAAE;gBACX,CAAC,CAAC;cACJ;cAEA,IAAImH,SAAS,CAACtK,QAAQ,IAAIsK,SAAS,CAACC,OAAO,EAAE;gBAC3C,MAAMC,SAAS,GAAGF,SAAS,CAACE,SAAS;gBACrC,MAAMK,gBAAgB,GAAGL,SAAS,CAACtC,OAAO,CAAC,CAAC,GAAGoC,SAAS,CAACtK,QAAQ,GAAG,IAAI;gBACxE,IAAI,CAAC0C,QAAQ,CAAC+B,UAAU,CAACoF,KAAK,CAAC,CAACU,OAAO,GAAG,IAAIxJ,IAAI,CAAC8J,gBAAgB,CAAC;cACtE;cAEA,IAAI,CAAC/F,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,EAAE;gBAChChG,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,GAAGR,SAAS;cACzC,CAAC,MAAM;gBACL,KAAK,MAAMS,SAAS,IAAIjG,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,EAAE;kBACnD,IAAI,CAAC,CAACR,SAAS,CAACS,SAAS,CAAC,IAAIC,IAAI,CAACC,SAAS,CAACnG,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,KAAKC,IAAI,CAACC,SAAS,CAACX,SAAS,CAACS,SAAS,CAAC,CAAC,EAAE;oBAC7H,IAAI,CAAChO,OAAO,CAAC,MAAM,EAAE;sBACnBoG,OAAO,EAAE;oBACX,CAAC,CAAC;oBACF;kBACF;gBACF,CAAC,CAAC;;gBAGF,MAAM+H,mBAAmB,GAAG,IAAI,CAACxI,QAAQ,CAAC+B,UAAU,CAAC0G,SAAS,CAACC,eAAe,IAAIA,eAAe,CAACN,EAAE,KAAKR,SAAS,CAACQ,EAAE,CAAC;gBACtH,IAAI,CAACpI,QAAQ,CAAC+B,UAAU,CAACyG,mBAAmB,CAAC,GAAG5O,QAAQ,CAAC,IAAI,CAACoG,QAAQ,CAAC+B,UAAU,CAACyG,mBAAmB,CAAC,EAAEZ,SAAS,CAAC;gBAClHxF,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,GAAGxO,QAAQ,CAACwI,aAAa,CAACwF,SAAS,CAACQ,EAAE,CAAC,EAAER,SAAS,CAAC,CAAC,CAAC;;gBAEhF,IAAI,CAAC5H,QAAQ,CAAC+B,UAAU,CAAC4G,GAAG,CAAC,CAAC;cAChC;YACF,CAAC;YAED,sBAAsBC,CAAA,EAAG;cACvB,IAAI,CAAC5I,QAAQ,CAAC6I,mBAAmB,GAAG,IAAI;YAC1C,CAAC;YAED,eAAeC,CAAA,EAAG;cAChB,IAAI,CAAC9I,QAAQ,CAAC+I,WAAW,GAAG,IAAI;cAChC,IAAI,CAACC,4BAA4B,CAAC,IAAI,CAAChJ,QAAQ,CAACvC,OAAO,EAAE,CAAC,CAAC;YAC7D,CAAC;YAED,kBAAkBwL,CAAA,EAAG;cACnB,IAAI,CAACjJ,QAAQ,CAACkJ,eAAe,GAAGtJ,aAAa,CAAC8C,KAAK,CAAClH,UAAU,CAAC;cAC/D,IAAI,CAAC+K,wBAAwB,CAAC,yBAAyB,EAAE7D,KAAK,CAAClH,UAAU,EAAE,CAAC,YAAY,CAAC,CAAC;YAC5F,CAAC;YAED;YACA2N,MAAMA,CAAA,EAAG;cACP,IAAI,CAACnJ,QAAQ,CAAC6C,WAAW,GAAG,IAAI,CAAC7C,QAAQ,CAAC6C,WAAW,IAAI,CAAC,CAAC;cAE3D,MAAMuG,MAAM,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;gBACvB,IAAID,CAAC,IAAI,IAAI,CAACrJ,QAAQ,CAAC6C,WAAW,EAAE;kBAClC;kBACA;kBACA;kBACA,IAAI,CAACxI,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE,gCAAgC4I,CAAC;kBAC5C,CAAC,CAAC;kBACF;gBACF;gBAEA,IAAI,CAACrJ,QAAQ,CAAC6C,WAAW,CAACwG,CAAC,CAAC,GAAGC,CAAC;cAClC,CAAC;cAED,IAAI,YAAY,IAAI5G,KAAK,CAAClH,UAAU,EAAE;gBACpC,IAAI,MAAM,IAAIkH,KAAK,CAAClH,UAAU,IAAI,QAAQ,IAAIkH,KAAK,CAAClH,UAAU,EAAE;kBAC9D;kBACA;kBACA;kBACA,IAAI,CAACnB,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE;kBACX,CAAC,CAAC;kBACF;gBACF;gBAEA,MAAM8I,GAAG,GAAG,IAAI,CAACvI,MAAM,CAACwI,GAAG,CAAC9G,KAAK,CAAClH,UAAU,CAACiO,UAAU,CAAC;gBAExD,IAAI,CAACF,GAAG,EAAE;kBACR;kBACA;kBACA;kBACA;kBACA,IAAI,CAAClP,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE,gCAAgCiC,KAAK,CAAClH,UAAU,CAACiO,UAAU;kBACtE,CAAC,CAAC;kBACF;gBACF;gBAEAL,MAAM,CAAC1G,KAAK,CAAClH,UAAU,CAACiO,UAAU,EAAEC,kBAAkB,CAACH,GAAG,CAAC,CAAC;gBAC5D;cACF;cAEA,IAAI,MAAM,IAAI7G,KAAK,CAAClH,UAAU,EAAE;gBAC9B,IAAI,QAAQ,IAAIkH,KAAK,CAAClH,UAAU,EAAE;kBAChC;kBACA;kBACA;kBACA,IAAI,CAACnB,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE;kBACX,CAAC,CAAC;kBACF;gBACF;gBAEA,IAAI,EAAE,OAAO,IAAIiC,KAAK,CAAClH,UAAU,CAAC,IAAI,OAAOkH,KAAK,CAAClH,UAAU,CAACmO,KAAK,KAAK,QAAQ,EAAE;kBAChF;kBACA;kBACA,IAAI,CAACtP,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE,8BAA8BiC,KAAK,CAAClH,UAAU,CAACiJ,IAAI;kBAC9D,CAAC,CAAC;kBACF;gBACF;gBAEA2E,MAAM,CAAC1G,KAAK,CAAClH,UAAU,CAACiJ,IAAI,EAAE/B,KAAK,CAAClH,UAAU,CAACmO,KAAK,CAAC;gBACrD;cACF;cAEA,IAAI,QAAQ,IAAIjH,KAAK,CAAClH,UAAU,EAAE;gBAChC,IAAI,CAAC,IAAI,CAACuF,eAAe,CAAC2B,KAAK,CAAClH,UAAU,CAACoO,MAAM,CAAC,EAAE;kBAClD;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA;kBACA,IAAI,CAACvP,OAAO,CAAC,OAAO,EAAE;oBACpBoG,OAAO,EAAE,0BAA0BiC,KAAK,CAAClH,UAAU,CAACoO,MAAM;kBAC5D,CAAC,CAAC;kBACF;gBACF;gBAEAR,MAAM,CAAC1G,KAAK,CAAClH,UAAU,CAACoO,MAAM,EAAE,IAAI,CAAC7I,eAAe,CAAC2B,KAAK,CAAClH,UAAU,CAACoO,MAAM,CAAC,CAAC;gBAC9E;cACF,CAAC,CAAC;cACF;cACA;;cAGA,IAAI,CAACvP,OAAO,CAAC,OAAO,EAAE;gBACpBoG,OAAO,EAAE;cACX,CAAC,CAAC;YACJ,CAAC;YAED,kBAAkBoJ,CAAA,EAAG;cACnB,IAAI,CAAC7J,QAAQ,CAACgC,eAAe,CAAC/H,IAAI,CAAC;gBACjCuB,UAAU,EAAEkH,KAAK,CAAClH,UAAU;gBAC5BkB,GAAG,EAAEgG,KAAK,CAAChG,GAAG;gBACd8F,QAAQ,EAAEZ;cACZ,CAAC,CAAC;cACF,IAAI,CAAC2E,wBAAwB,CAAC,2BAA2B,EAAE7D,KAAK,CAAClH,UAAU,EAAE,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;YACpG;UAEF,CAAC,CAAEkH,KAAK,CAACrF,OAAO,CAAC,IAAIoE,IAAI,EAAEtE,IAAI,CAACiE,IAAI,CAAC;QACvC,CAAC;QAED1E,GAAGA,CAAA,EAAG;UACJ4E,UAAU,CAAC5E,GAAG,GAAGgG,KAAK,CAAChG,GAAG;UAC1B2E,IAAI,CAACpH,IAAI,CAACqH,UAAU,CAAC,CAAC,CAAC;;UAEvB,IAAI,IAAI,CAACtB,QAAQ,CAACE,cAAc,IAAI,EAAE,UAAU,IAAIoB,UAAU,CAAC,EAAE;YAC/D,IAAI,CAACjH,OAAO,CAAC,MAAM,EAAE;cACnBoG,OAAO,EAAE;YACX,CAAC,CAAC;YACFa,UAAU,CAAChE,QAAQ,GAAG,IAAI,CAAC0C,QAAQ,CAACE,cAAc;UACpD,CAAC,CAAC;;UAGF,IAAI/E,GAAG,EAAE;YACPmG,UAAU,CAACnG,GAAG,GAAGA,GAAG;UACtB;UAEAmG,UAAU,CAACkB,QAAQ,GAAGZ,eAAe,CAAC,CAAC;;UAEvC,IAAIL,UAAU,EAAE;YACdD,UAAU,CAAChC,GAAG,GAAGiC,UAAU;UAC7B,CAAC,CAAC;;UAGFY,oBAAoB,GAAG,CAAC,CAAC,CAAC;;UAE1B,IAAI,IAAI,CAAChB,mBAAmB,KAAK,IAAI,EAAE;YACrCG,UAAU,CAACoE,eAAe,GAAG,IAAI,CAACvE,mBAAmB;YACrD,IAAI,CAACA,mBAAmB,IAAIG,UAAU,CAAChE,QAAQ,GAAG,IAAI;UACxD,CAAC,CAAC;;UAGFgE,UAAU,GAAG,CAAC,CAAC;QACjB,CAAC;QAEDwI,OAAOA,CAAA,EAAG,CAAC;QAAA,CACV;QAEDC,MAAMA,CAAA,EAAG;UACP;UACA,IAAIrH,KAAK,CAACtD,OAAO,EAAE;YACjBkC,UAAU,CAACyI,MAAM,GAAGzI,UAAU,CAACyI,MAAM,IAAI,CAAC,CAAC;YAC3CzI,UAAU,CAACyI,MAAM,CAACrH,KAAK,CAACxD,UAAU,CAAC,GAAGwD,KAAK,CAACxI,IAAI,CAAC,CAAC;UACpD,CAAC,MAAM;YACL,IAAI,CAAC8F,QAAQ,CAAC+J,MAAM,GAAG,IAAI,CAAC/J,QAAQ,CAAC+J,MAAM,IAAI,CAAC,CAAC;YACjD,IAAI,CAAC/J,QAAQ,CAAC+J,MAAM,CAACrH,KAAK,CAACxD,UAAU,CAAC,GAAGwD,KAAK,CAACxI,IAAI;UACrD;QACF;MAEF,CAAC,EAAEwI,KAAK,CAACjG,IAAI,CAAC,CAACU,IAAI,CAACiE,IAAI,CAAC;IAC3B,CAAC,CAAC;EACJ;EAEA4H,4BAA4BA,CAACgB,cAAc,EAAEC,aAAa,EAAE;IAC1D,IAAID,cAAc,GAAGC,aAAa,IAAI,CAACD,cAAc,EAAE;MACrD,IAAI,CAAC3P,OAAO,CAAC,MAAM,EAAE;QACnBoG,OAAO,EAAE,qCAAqCwJ,aAAa;MAC7D,CAAC,CAAC;IACJ;EACF;EAEA1D,wBAAwBA,CAAC2D,UAAU,EAAE1O,UAAU,EAAE+L,QAAQ,EAAE;IACzD,MAAM4C,OAAO,GAAG,EAAE;IAClB5C,QAAQ,CAACtK,OAAO,CAAC,UAAU9B,GAAG,EAAE;MAC9B,IAAI,CAACK,UAAU,CAACkD,cAAc,CAACvD,GAAG,CAAC,EAAE;QACnCgP,OAAO,CAAClQ,IAAI,CAACkB,GAAG,CAAC;MACnB;IACF,CAAC,CAAC;IAEF,IAAIgP,OAAO,CAACpP,MAAM,EAAE;MAClB,IAAI,CAACV,OAAO,CAAC,MAAM,EAAE;QACnBoG,OAAO,EAAE,GAAGyJ,UAAU,iCAAiCC,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC;MAC3E,CAAC,CAAC;IACJ;EACF;EACA;AACF;AACA;AACA;AACA;;EAGEnQ,IAAIA,CAACoQ,KAAK,EAAE;IACV,IAAI,CAACzJ,UAAU,CAAC3G,IAAI,CAACoQ,KAAK,CAAC;EAC7B;EACA;AACF;AACA;AACA;AACA;;EAGEC,GAAGA,CAAA,EAAG;IACJ;IACA,IAAI,CAAC1J,UAAU,CAAC3G,IAAI,CAAC,IAAI,CAAC;IAE1B,IAAI,IAAI,CAAC+F,QAAQ,CAAC+B,UAAU,CAAChH,MAAM,IAAI,IAAI,CAACoG,mBAAmB,KAAK,IAAI,EAAE;MACxE,IAAI,CAAC9G,OAAO,CAAC,MAAM,EAAE;QACnBoG,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;IAEA,IAAI,CAACU,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAAC9G,OAAO,CAAC,KAAK,CAAC;EACrB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE2E,SAASA,CAACuL,OAAO,EAAE;IACjB,IAAI,CAAC1J,WAAW,CAAC7B,SAAS,CAACuL,OAAO,CAAC;EACrC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGElL,YAAYA,CAACkL,OAAO,EAAE;IACpB,IAAI,CAAC1J,WAAW,CAACxB,YAAY,CAACkL,OAAO,CAAC;EACxC;AAEF;AAEA,SAASzQ,UAAU,EAAEqC,WAAW,EAAEuE,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}