{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ])\\s+([^ ]+)\\s+(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\nvar cache = {};\nmodule.exports = function (proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function (ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function (ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function (flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function () {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function (callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n    async.waterfall([\n    // Try FFMPEG_PATH\n    function (cb) {\n      if (process.env.FFMPEG_PATH) {\n        fs.exists(process.env.FFMPEG_PATH, function (exists) {\n          if (exists) {\n            cb(null, process.env.FFMPEG_PATH);\n          } else {\n            cb(null, '');\n          }\n        });\n      } else {\n        cb(null, '');\n      }\n    },\n    // Search in the PATH\n    function (ffmpeg, cb) {\n      if (ffmpeg.length) {\n        return cb(null, ffmpeg);\n      }\n      utils.which('ffmpeg', function (err, ffmpeg) {\n        cb(err, ffmpeg);\n      });\n    }], function (err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = ffmpeg || '');\n      }\n    });\n  };\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function (callback) {\n    var self = this;\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n    async.waterfall([\n    // Try FFPROBE_PATH\n    function (cb) {\n      if (process.env.FFPROBE_PATH) {\n        fs.exists(process.env.FFPROBE_PATH, function (exists) {\n          cb(null, exists ? process.env.FFPROBE_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    },\n    // Search in the PATH\n    function (ffprobe, cb) {\n      if (ffprobe.length) {\n        return cb(null, ffprobe);\n      }\n      utils.which('ffprobe', function (err, ffprobe) {\n        cb(err, ffprobe);\n      });\n    },\n    // Search in the same directory as ffmpeg\n    function (ffprobe, cb) {\n      if (ffprobe.length) {\n        return cb(null, ffprobe);\n      }\n      self._getFfmpegPath(function (err, ffmpeg) {\n        if (err) {\n          cb(err);\n        } else if (ffmpeg.length) {\n          var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n          var ffprobe = path.join(path.dirname(ffmpeg), name);\n          fs.exists(ffprobe, function (exists) {\n            cb(null, exists ? ffprobe : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      });\n    }], function (err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = ffprobe || '');\n      }\n    });\n  };\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFlvtoolPath = function (callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n    async.waterfall([\n    // Try FLVMETA_PATH\n    function (cb) {\n      if (process.env.FLVMETA_PATH) {\n        fs.exists(process.env.FLVMETA_PATH, function (exists) {\n          cb(null, exists ? process.env.FLVMETA_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    },\n    // Try FLVTOOL2_PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n      if (process.env.FLVTOOL2_PATH) {\n        fs.exists(process.env.FLVTOOL2_PATH, function (exists) {\n          cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n        });\n      } else {\n        cb(null, '');\n      }\n    },\n    // Search for flvmeta in the PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n      utils.which('flvmeta', function (err, flvmeta) {\n        cb(err, flvmeta);\n      });\n    },\n    // Search for flvtool2 in the PATH\n    function (flvtool, cb) {\n      if (flvtool.length) {\n        return cb(null, flvtool);\n      }\n      utils.which('flvtool2', function (err, flvtool2) {\n        cb(err, flvtool2);\n      });\n    }], function (err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = flvtool || '');\n      }\n    });\n  };\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters = proto.getAvailableFilters = function (callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n    this._spawnFfmpeg(['-filters'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = {\n        A: 'audio',\n        V: 'video',\n        '|': 'none'\n      };\n      lines.forEach(function (line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n      callback(null, cache.filters = data);\n    });\n  };\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs = proto.getAvailableCodecs = function (callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n    this._spawnFfmpeg(['-codecs'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n            encoders.forEach(function (name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n            decoders.forEach(function (name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n      callback(null, cache.codecs = data);\n    });\n  };\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders = proto.getAvailableEncoders = function (callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n    this._spawnFfmpeg(['-encoders'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: {\n              'V': 'video',\n              'A': 'audio',\n              'S': 'subtitle'\n            }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n      callback(null, cache.encoders = data);\n    });\n  };\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats = proto.getAvailableFormats = function (callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], {\n      captureStdout: true,\n      stdoutLines: 0\n    }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n      lines.forEach(function (line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function (format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n      callback(null, cache.formats = data);\n    });\n  };\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function (callback) {\n    var self = this;\n    async.waterfall([\n    // Get available formats\n    function (cb) {\n      self.availableFormats(cb);\n    },\n    // Check whether specified formats are available\n    function (formats, cb) {\n      var unavailable;\n\n      // Output format(s)\n      unavailable = self._outputs.reduce(function (fmts, output) {\n        var format = output.options.find('-f', 1);\n        if (format) {\n          if (!(format[0] in formats) || !formats[format[0]].canMux) {\n            fmts.push(format);\n          }\n        }\n        return fmts;\n      }, []);\n      if (unavailable.length === 1) {\n        return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n      }\n\n      // Input format(s)\n      unavailable = self._inputs.reduce(function (fmts, input) {\n        var format = input.options.find('-f', 1);\n        if (format) {\n          if (!(format[0] in formats) || !formats[format[0]].canDemux) {\n            fmts.push(format[0]);\n          }\n        }\n        return fmts;\n      }, []);\n      if (unavailable.length === 1) {\n        return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n      }\n      cb();\n    },\n    // Get available codecs\n    function (cb) {\n      self.availableEncoders(cb);\n    },\n    // Check whether specified codecs are available and add strict experimental options if needed\n    function (encoders, cb) {\n      var unavailable;\n\n      // Audio codec(s)\n      unavailable = self._outputs.reduce(function (cdcs, output) {\n        var acodec = output.audio.find('-acodec', 1);\n        if (acodec && acodec[0] !== 'copy') {\n          if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n            cdcs.push(acodec[0]);\n          }\n        }\n        return cdcs;\n      }, []);\n      if (unavailable.length === 1) {\n        return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n      }\n\n      // Video codec(s)\n      unavailable = self._outputs.reduce(function (cdcs, output) {\n        var vcodec = output.video.find('-vcodec', 1);\n        if (vcodec && vcodec[0] !== 'copy') {\n          if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n            cdcs.push(vcodec[0]);\n          }\n        }\n        return cdcs;\n      }, []);\n      if (unavailable.length === 1) {\n        return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n      } else if (unavailable.length > 1) {\n        return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n      }\n      cb();\n    }], callback);\n  };\n};","map":{"version":3,"names":["fs","require","path","async","utils","avCodecRegexp","ffCodecRegexp","ffEncodersRegexp","ffDecodersRegexp","encodersRegexp","formatRegexp","lineBreakRegexp","filterRegexp","cache","module","exports","proto","setFfmpegPath","ffmpegPath","setFfprobePath","ffprobePath","setFlvtoolPath","flvtool","flvtoolPath","_forgetPaths","_getFfmpegPath","callback","waterfall","cb","process","env","FFMPEG_PATH","exists","ffmpeg","length","which","err","_getFfprobePath","self","FFPROBE_PATH","ffprobe","name","isWindows","join","dirname","_getFlvtoolPath","FLVMETA_PATH","FLVTOOL2_PATH","flvmeta","flvtool2","availableFilters","getAvailableFilters","filters","_spawnFfmpeg","captureStdout","stdoutLines","stdoutRing","stdout","get","lines","split","data","types","A","V","forEach","line","match","description","input","charAt","multipleInputs","output","multipleOutputs","availableCodecs","getAvailableCodecs","codecs","type","canDecode","canEncode","drawHorizBand","directRendering","weirdFrameTruncation","codecData","intraFrameOnly","isLossy","isLossless","encoders","trim","decoders","coderData","copy","availableEncoders","getAvailableEncoders","frameMT","sliceMT","experimental","availableFormats","getAvailableFormats","formats","format","canDemux","canMux","_checkCapabilities","unavailable","_outputs","reduce","fmts","options","find","push","Error","_inputs","cdcs","acodec","audio","vcodec","video"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/capabilities.js"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ])\\s+([^ ]+)\\s+(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\n\nvar cache = {};\n\nmodule.exports = function(proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function(ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function(ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function(flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function() {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function(callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([\n      // Try FFMPEG_PATH\n      function(cb) {\n        if (process.env.FFMPEG_PATH) {\n          fs.exists(process.env.FFMPEG_PATH, function(exists) {\n            if (exists) {\n              cb(null, process.env.FFMPEG_PATH);\n            } else {\n              cb(null, '');\n            }\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffmpeg, cb) {\n        if (ffmpeg.length) {\n          return cb(null, ffmpeg);\n        }\n\n        utils.which('ffmpeg', function(err, ffmpeg) {\n          cb(err, ffmpeg);\n        });\n      }\n    ], function(err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = (ffmpeg || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function(callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([\n      // Try FFPROBE_PATH\n      function(cb) {\n        if (process.env.FFPROBE_PATH) {\n          fs.exists(process.env.FFPROBE_PATH, function(exists) {\n            cb(null, exists ? process.env.FFPROBE_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        utils.which('ffprobe', function(err, ffprobe) {\n          cb(err, ffprobe);\n        });\n      },\n\n      // Search in the same directory as ffmpeg\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        self._getFfmpegPath(function(err, ffmpeg) {\n          if (err) {\n            cb(err);\n          } else if (ffmpeg.length) {\n            var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n            var ffprobe = path.join(path.dirname(ffmpeg), name);\n            fs.exists(ffprobe, function(exists) {\n              cb(null, exists ? ffprobe : '');\n            });\n          } else {\n            cb(null, '');\n          }\n        });\n      }\n    ], function(err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = (ffprobe || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n   proto._getFlvtoolPath = function(callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([\n      // Try FLVMETA_PATH\n      function(cb) {\n        if (process.env.FLVMETA_PATH) {\n          fs.exists(process.env.FLVMETA_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVMETA_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Try FLVTOOL2_PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        if (process.env.FLVTOOL2_PATH) {\n          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search for flvmeta in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvmeta', function(err, flvmeta) {\n          cb(err, flvmeta);\n        });\n      },\n\n      // Search for flvtool2 in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvtool2', function(err, flvtool2) {\n          cb(err, flvtool2);\n        });\n      },\n    ], function(err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = (flvtool || ''));\n      }\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters =\n  proto.getAvailableFilters = function(callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = { A: 'audio', V: 'video', '|': 'none' };\n\n      lines.forEach(function(line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n\n      callback(null, cache.filters = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs =\n  proto.getAvailableCodecs = function(callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n\n            encoders.forEach(function(name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n\n            decoders.forEach(function(name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n\n      callback(null, cache.codecs = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders =\n  proto.getAvailableEncoders = function(callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n\n      callback(null, cache.encoders = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats =\n  proto.getAvailableFormats = function(callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function(format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n\n      callback(null, cache.formats = data);\n    });\n  };\n\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function(callback) {\n    var self = this;\n    async.waterfall([\n      // Get available formats\n      function(cb) {\n        self.availableFormats(cb);\n      },\n\n      // Check whether specified formats are available\n      function(formats, cb) {\n        var unavailable;\n\n        // Output format(s)\n        unavailable = self._outputs\n          .reduce(function(fmts, output) {\n            var format = output.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canMux)) {\n                fmts.push(format);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Input format(s)\n        unavailable = self._inputs\n          .reduce(function(fmts, input) {\n            var format = input.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {\n                fmts.push(format[0]);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      },\n\n      // Get available codecs\n      function(cb) {\n        self.availableEncoders(cb);\n      },\n\n      // Check whether specified codecs are available and add strict experimental options if needed\n      function(encoders, cb) {\n        var unavailable;\n\n        // Audio codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var acodec = output.audio.find('-acodec', 1);\n          if (acodec && acodec[0] !== 'copy') {\n            if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n              cdcs.push(acodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Video codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var vcodec = output.video.find('-vcodec', 1);\n          if (vcodec && vcodec[0] !== 'copy') {\n            if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n              cdcs.push(vcodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      }\n    ], callback);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}