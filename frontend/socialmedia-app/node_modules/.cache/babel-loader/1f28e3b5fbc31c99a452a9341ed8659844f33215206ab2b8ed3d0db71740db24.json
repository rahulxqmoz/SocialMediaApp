{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\nvar path = require('path');\nvar fs = require('fs');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Processor methods\n */\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function (err, data) {\n    command._ffprobeData = data;\n  });\n}\nmodule.exports = function (proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function (args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function () {};\n    }\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function (err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n      ffmpegProc.on('error', function (err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function (code, signal) {\n        processExited = true;\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function (data) {\n          stdoutRing.append(data);\n        });\n        ffmpegProc.stdout.on('close', function () {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function (data) {\n        stderrRing.append(data);\n      });\n      ffmpegProc.stderr.on('close', function () {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function () {\n    var complexFilters = this._complexFilters.get();\n    var fileOutput = this._outputs.some(function (output) {\n      return output.isFile;\n    });\n    return [].concat(\n    // Inputs and input options\n    this._inputs.reduce(function (args, input) {\n      var source = typeof input.source === 'string' ? input.source : 'pipe:0';\n\n      // For each input, add input options, then '-i <source>'\n      return args.concat(input.options.get(), ['-i', source]);\n    }, []),\n    // Global options\n    this._global.get(),\n    // Overwrite if we have file outputs\n    fileOutput ? ['-y'] : [],\n    // Complex filters\n    complexFilters,\n    // Outputs, filters and output options\n    this._outputs.reduce(function (args, output) {\n      var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n      var audioFilters = output.audioFilters.get();\n      var videoFilters = output.videoFilters.get().concat(sizeFilters);\n      var outputArg;\n      if (!output.target) {\n        outputArg = [];\n      } else if (typeof output.target === 'string') {\n        outputArg = [output.target];\n      } else {\n        outputArg = ['pipe:1'];\n      }\n      return args.concat(output.audio.get(), audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [], output.video.get(), videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [], output.options.get(), outputArg);\n    }, []));\n  };\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function (callback, readMetadata) {\n    var self = this;\n    async.waterfall([\n    // Check codecs and formats\n    function (cb) {\n      self._checkCapabilities(cb);\n    },\n    // Read metadata if required\n    function (cb) {\n      if (!readMetadata) {\n        return cb();\n      }\n      self.ffprobe(0, function (err, data) {\n        if (!err) {\n          self._ffprobeData = data;\n        }\n        cb();\n      });\n    },\n    // Check for flvtool2/flvmeta if necessary\n    function (cb) {\n      var flvmeta = self._outputs.some(function (output) {\n        // Remove flvmeta flag on non-file output\n        if (output.flags.flvmeta && !output.isFile) {\n          self.logger.warn('Updating flv metadata is only supported for files');\n          output.flags.flvmeta = false;\n        }\n        return output.flags.flvmeta;\n      });\n      if (flvmeta) {\n        self._getFlvtoolPath(function (err) {\n          cb(err);\n        });\n      } else {\n        cb();\n      }\n    },\n    // Build argument list\n    function (cb) {\n      var args;\n      try {\n        args = self._getArguments();\n      } catch (e) {\n        return cb(e);\n      }\n      cb(null, args);\n    },\n    // Add \"-strict experimental\" option where needed\n    function (args, cb) {\n      self.availableEncoders(function (err, encoders) {\n        for (var i = 0; i < args.length; i++) {\n          if (args[i] === '-acodec' || args[i] === '-vcodec') {\n            i++;\n            if (args[i] in encoders && encoders[args[i]].experimental) {\n              args.splice(i + 1, 0, '-strict', 'experimental');\n              i += 2;\n            }\n          }\n        }\n        cb(null, args);\n      });\n    }], callback);\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function (event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec = proto.execute = proto.run = function () {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function (output) {\n      return 'target' in output;\n    });\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function (output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function (input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n    self._prepare(function (err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(args, {\n        captureStdout: !outputStream,\n        niceness: self.options.niceness,\n        cwd: self.options.cwd,\n        windowsHide: true\n      }, function processCB(ffmpegProc, stdoutRing, stderrRing) {\n        self.ffmpegProc = ffmpegProc;\n        self.emit('start', 'ffmpeg ' + args.join(' '));\n\n        // Pipe input stream if any\n        if (inputStream) {\n          inputStream.source.on('error', function (err) {\n            var reportingErr = new Error('Input stream error: ' + err.message);\n            reportingErr.inputStreamError = err;\n            emitEnd(reportingErr);\n            ffmpegProc.kill();\n          });\n          inputStream.source.resume();\n          inputStream.source.pipe(ffmpegProc.stdin);\n\n          // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n          // ffmpeg will fail anyway, so no need to actually handle anything)\n          ffmpegProc.stdin.on('error', function () {});\n        }\n\n        // Setup timeout if requested\n        if (self.options.timeout) {\n          self.processTimer = setTimeout(function () {\n            var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n            emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n            ffmpegProc.kill();\n          }, self.options.timeout * 1000);\n        }\n        if (outputStream) {\n          // Pipe ffmpeg stdout to output stream\n          ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n          // Handle output stream events\n          outputStream.target.on('close', function () {\n            self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n            // Don't kill process yet, to give a chance to ffmpeg to\n            // terminate successfully first  This is necessary because\n            // under load, the process 'exit' event sometimes happens\n            // after the output stream 'close' event.\n            setTimeout(function () {\n              emitEnd(new Error('Output stream closed'));\n              ffmpegProc.kill();\n            }, 20);\n          });\n          outputStream.target.on('error', function (err) {\n            self.logger.debug('Output stream error, killing ffmpeg process');\n            var reportingErr = new Error('Output stream error: ' + err.message);\n            reportingErr.outputStreamError = err;\n            emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n            ffmpegProc.kill('SIGKILL');\n          });\n        }\n\n        // Setup stderr handling\n        if (stderrRing) {\n          // 'stderr' event\n          if (self.listeners('stderr').length) {\n            stderrRing.callback(function (line) {\n              self.emit('stderr', line);\n            });\n          }\n\n          // 'codecData' event\n          if (self.listeners('codecData').length) {\n            var codecDataSent = false;\n            var codecObject = {};\n            stderrRing.callback(function (line) {\n              if (!codecDataSent) codecDataSent = utils.extractCodecData(self, line, codecObject);\n            });\n          }\n\n          // 'progress' event\n          if (self.listeners('progress').length) {\n            stderrRing.callback(function (line) {\n              utils.extractProgress(self, line);\n            });\n          }\n        }\n      }, function endCB(err, stdoutRing, stderrRing) {\n        clearTimeout(self.processTimer);\n        delete self.ffmpegProc;\n        if (err) {\n          if (err.message.match(/ffmpeg exited with code/)) {\n            // Add ffmpeg error message\n            err.message += ': ' + utils.extractError(stderrRing.get());\n          }\n          emitEnd(err, stdoutRing.get(), stderrRing.get());\n        } else {\n          // Find out which outputs need flv metadata\n          var flvmeta = self._outputs.filter(function (output) {\n            return output.flags.flvmeta;\n          });\n          if (flvmeta.length) {\n            self._getFlvtoolPath(function (err, flvtool) {\n              if (err) {\n                return emitEnd(err);\n              }\n              async.each(flvmeta, function (output, cb) {\n                spawn(flvtool, ['-U', output.target], {\n                  windowsHide: true\n                }).on('error', function (err) {\n                  cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                }).on('exit', function (code, signal) {\n                  if (code !== 0 || signal) {\n                    cb(new Error(flvtool + ' ' + (signal ? 'received signal ' + signal : 'exited with code ' + code)) + ' when running on ' + output.target);\n                  } else {\n                    cb();\n                  }\n                });\n              }, function (err) {\n                if (err) {\n                  emitEnd(err);\n                } else {\n                  emitEnd(null, stdoutRing.get(), stderrRing.get());\n                }\n              });\n            });\n          } else {\n            emitEnd(null, stdoutRing.get(), stderrRing.get());\n          }\n        }\n      });\n    });\n    return this;\n  };\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function (niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid], {\n          windowsHide: true\n        });\n        renice.on('error', function (err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n        renice.on('exit', function (code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function (signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n    return this;\n  };\n};","map":{"version":3,"names":["spawn","require","path","fs","async","utils","runFfprobe","command","inputProbeIndex","_inputs","isStream","ffprobe","err","data","_ffprobeData","module","exports","proto","_spawnFfmpeg","args","options","processCB","endCB","maxLines","stdoutLines","_getFfmpegPath","length","Error","niceness","isWindows","unshift","stdoutRing","linesRing","stdoutClosed","stderrRing","stderrClosed","ffmpegProc","stderr","setEncoding","on","exitError","handleExit","processExited","captureStdout","code","signal","stdout","append","close","_getArguments","complexFilters","_complexFilters","get","fileOutput","_outputs","some","output","isFile","concat","reduce","input","source","_global","sizeFilters","makeFilterStrings","audioFilters","videoFilters","outputArg","target","audio","join","video","_prepare","callback","readMetadata","self","waterfall","cb","_checkCapabilities","flvmeta","flags","logger","warn","_getFlvtoolPath","e","availableEncoders","encoders","i","experimental","splice","listeners","once","event","exec","execute","run","outputPresent","outputStream","filter","inputStream","ended","emitEnd","emit","cwd","windowsHide","reportingErr","message","inputStreamError","kill","resume","pipe","stdin","timeout","processTimer","setTimeout","msg","pipeopts","debug","outputStreamError","line","codecDataSent","codecObject","extractCodecData","extractProgress","clearTimeout","match","extractError","flvtool","each","renice","Math","min","max","pid","info"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/processor.js"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\nvar path = require('path');\nvar fs = require('fs');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Processor methods\n */\n\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function(err, data) {\n    command._ffprobeData = data;\n  });\n}\n\n\nmodule.exports = function(proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function(args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function() {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function(err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function(err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function(data) {\n          stdoutRing.append(data);\n        });\n\n        ffmpegProc.stdout.on('close', function() {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function(data) {\n        stderrRing.append(data);\n      });\n\n      ffmpegProc.stderr.on('close', function() {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function() {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function(output) {\n      return output.isFile;\n    });\n\n    return [].concat(\n        // Inputs and input options\n        this._inputs.reduce(function(args, input) {\n          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';\n\n          // For each input, add input options, then '-i <source>'\n          return args.concat(\n            input.options.get(),\n            ['-i', source]\n          );\n        }, []),\n\n        // Global options\n        this._global.get(),\n\n        // Overwrite if we have file outputs\n        fileOutput ? ['-y'] : [],\n\n        // Complex filters\n        complexFilters,\n\n        // Outputs, filters and output options\n        this._outputs.reduce(function(args, output) {\n          var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n          var audioFilters = output.audioFilters.get();\n          var videoFilters = output.videoFilters.get().concat(sizeFilters);\n          var outputArg;\n\n          if (!output.target) {\n            outputArg = [];\n          } else if (typeof output.target === 'string') {\n            outputArg = [output.target];\n          } else {\n            outputArg = ['pipe:1'];\n          }\n\n          return args.concat(\n            output.audio.get(),\n            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],\n            output.video.get(),\n            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],\n            output.options.get(),\n            outputArg\n          );\n        }, [])\n      );\n  };\n\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function(callback, readMetadata) {\n    var self = this;\n\n    async.waterfall([\n      // Check codecs and formats\n      function(cb) {\n        self._checkCapabilities(cb);\n      },\n\n      // Read metadata if required\n      function(cb) {\n        if (!readMetadata) {\n          return cb();\n        }\n\n        self.ffprobe(0, function(err, data) {\n          if (!err) {\n            self._ffprobeData = data;\n          }\n\n          cb();\n        });\n      },\n\n      // Check for flvtool2/flvmeta if necessary\n      function(cb) {\n        var flvmeta = self._outputs.some(function(output) {\n          // Remove flvmeta flag on non-file output\n          if (output.flags.flvmeta && !output.isFile) {\n            self.logger.warn('Updating flv metadata is only supported for files');\n            output.flags.flvmeta = false;\n          }\n\n          return output.flags.flvmeta;\n        });\n\n        if (flvmeta) {\n          self._getFlvtoolPath(function(err) {\n            cb(err);\n          });\n        } else {\n          cb();\n        }\n      },\n\n      // Build argument list\n      function(cb) {\n        var args;\n        try {\n          args = self._getArguments();\n        } catch(e) {\n          return cb(e);\n        }\n\n        cb(null, args);\n      },\n\n      // Add \"-strict experimental\" option where needed\n      function(args, cb) {\n        self.availableEncoders(function(err, encoders) {\n          for (var i = 0; i < args.length; i++) {\n            if (args[i] === '-acodec' || args[i] === '-vcodec') {\n              i++;\n\n              if ((args[i] in encoders) && encoders[args[i]].experimental) {\n                args.splice(i + 1, 0, '-strict', 'experimental');\n                i += 2;\n              }\n            }\n          }\n\n          cb(null, args);\n        });\n      }\n    ], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function(event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec =\n  proto.execute =\n  proto.run = function() {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function(output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function(output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function(input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function(err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(\n        args,\n        {\n          captureStdout: !outputStream,\n          niceness: self.options.niceness,\n          cwd: self.options.cwd,\n          windowsHide: true\n        }, \n\n        function processCB(ffmpegProc, stdoutRing, stderrRing) {\n          self.ffmpegProc = ffmpegProc;\n          self.emit('start', 'ffmpeg ' + args.join(' '));\n\n          // Pipe input stream if any\n          if (inputStream) {\n            inputStream.source.on('error', function(err) {\n              var reportingErr = new Error('Input stream error: ' + err.message);\n              reportingErr.inputStreamError = err;\n              emitEnd(reportingErr);\n              ffmpegProc.kill();\n            });\n\n            inputStream.source.resume();\n            inputStream.source.pipe(ffmpegProc.stdin);\n\n            // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n            // ffmpeg will fail anyway, so no need to actually handle anything)\n            ffmpegProc.stdin.on('error', function() {});\n          }\n\n          // Setup timeout if requested\n          if (self.options.timeout) {\n            self.processTimer = setTimeout(function() {\n              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n\n              emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill();\n            }, self.options.timeout * 1000);\n          }\n\n\n          if (outputStream) {\n            // Pipe ffmpeg stdout to output stream\n            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n            // Handle output stream events\n            outputStream.target.on('close', function() {\n              self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n              // Don't kill process yet, to give a chance to ffmpeg to\n              // terminate successfully first  This is necessary because\n              // under load, the process 'exit' event sometimes happens\n              // after the output stream 'close' event.\n              setTimeout(function() {\n                emitEnd(new Error('Output stream closed'));\n                ffmpegProc.kill();\n              }, 20);\n            });\n\n            outputStream.target.on('error', function(err) {\n              self.logger.debug('Output stream error, killing ffmpeg process');\n              var reportingErr = new Error('Output stream error: ' + err.message);\n              reportingErr.outputStreamError = err;\n              emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill('SIGKILL');\n            });\n          }\n\n          // Setup stderr handling\n          if (stderrRing) {\n\n            // 'stderr' event\n            if (self.listeners('stderr').length) {\n              stderrRing.callback(function(line) {\n                self.emit('stderr', line);\n              });\n            }\n\n            // 'codecData' event\n            if (self.listeners('codecData').length) {\n              var codecDataSent = false;\n              var codecObject = {};\n\n              stderrRing.callback(function(line) {\n                if (!codecDataSent)\n                  codecDataSent = utils.extractCodecData(self, line, codecObject);\n              });\n            }\n\n            // 'progress' event\n            if (self.listeners('progress').length) {\n              stderrRing.callback(function(line) {\n                utils.extractProgress(self, line);\n              });\n            }\n          }\n        },\n\n        function endCB(err, stdoutRing, stderrRing) {\n          clearTimeout(self.processTimer);\n          delete self.ffmpegProc;\n\n          if (err) {\n            if (err.message.match(/ffmpeg exited with code/)) {\n              // Add ffmpeg error message\n              err.message += ': ' + utils.extractError(stderrRing.get());\n            }\n\n            emitEnd(err, stdoutRing.get(), stderrRing.get());\n          } else {\n            // Find out which outputs need flv metadata\n            var flvmeta = self._outputs.filter(function(output) {\n              return output.flags.flvmeta;\n            });\n\n            if (flvmeta.length) {\n              self._getFlvtoolPath(function(err, flvtool) {\n                if (err) {\n                  return emitEnd(err);\n                }\n\n                async.each(\n                  flvmeta,\n                  function(output, cb) {\n                    spawn(flvtool, ['-U', output.target], {windowsHide: true})\n                      .on('error', function(err) {\n                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                      })\n                      .on('exit', function(code, signal) {\n                        if (code !== 0 || signal) {\n                          cb(\n                            new Error(flvtool + ' ' +\n                              (signal ? 'received signal ' + signal\n                                      : 'exited with code ' + code)) +\n                              ' when running on ' + output.target\n                          );\n                        } else {\n                          cb();\n                        }\n                      });\n                  },\n                  function(err) {\n                    if (err) {\n                      emitEnd(err);\n                    } else {\n                      emitEnd(null, stdoutRing.get(), stderrRing.get());\n                    }\n                  }\n                );\n              });\n            } else {\n              emitEnd(null, stdoutRing.get(), stderrRing.get());\n            }\n          }\n        }\n      );\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function(niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid], {windowsHide: true});\n\n        renice.on('error', function(err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n\n        renice.on('exit', function(code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function(signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}