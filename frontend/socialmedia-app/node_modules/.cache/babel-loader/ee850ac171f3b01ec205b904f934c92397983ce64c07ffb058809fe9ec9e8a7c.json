{"ast":null,"code":"/*jshint node:true, laxcomma:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\nfunction legacyTag(key) {\n  return key.match(/^TAG:/);\n}\nfunction legacyDisposition(key) {\n  return key.match(/^DISPOSITION:/);\n}\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n  function parseBlock(name) {\n    var data = {};\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/' + name + ']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!kv[1].match(/^TAG:/) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n      line = lines.shift();\n    }\n    return data;\n  }\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n    line = lines.shift();\n  }\n  return data;\n}\nmodule.exports = function (proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function () {\n    var input,\n      index = null,\n      options = [],\n      callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n    var ended = false;\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    }\n    ;\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function (err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src), {\n        windowsHide: true\n      });\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function (err) {\n          if (['ECONNRESET', 'EPIPE', 'EOF'].indexOf(err.code) >= 0) {\n            return;\n          }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function () {\n          input.source.pause();\n          input.source.unpipe(ffprobe.stdin);\n        });\n        input.source.pipe(ffprobe.stdin);\n      }\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function (target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n                legacyTagKeys.forEach(function (tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n                legacyDispositionKeys.forEach(function (dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function (code, signal) {\n        processExited = true;\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function (data) {\n        stdout += data;\n      });\n      ffprobe.stdout.on('close', function () {\n        stdoutClosed = true;\n        handleExit();\n      });\n      ffprobe.stderr.on('data', function (data) {\n        stderr += data;\n      });\n      ffprobe.stderr.on('close', function () {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};","map":{"version":3,"names":["spawn","require","legacyTag","key","match","legacyDisposition","parseFfprobeOutput","out","lines","split","filter","line","length","data","streams","format","chapters","parseBlock","name","shift","toLowerCase","kv","Number","stream","push","chapter","module","exports","proto","ffprobe","input","index","options","callback","arguments","ended","handleCallback","err","Array","isArray","_currentInput","Error","_inputs","_getFfprobePath","path","stdout","stdoutClosed","stderr","stderrClosed","src","isStream","source","concat","windowsHide","stdin","on","indexOf","code","pause","unpipe","pipe","exitError","handleExit","processExited","message","forEach","target","legacyTagKeys","Object","keys","tags","tagKey","substr","legacyDispositionKeys","disposition","dispositionKey","signal"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/ffprobe.js"],"sourcesContent":["/*jshint node:true, laxcomma:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\n\n\nfunction legacyTag(key) { return key.match(/^TAG:/); }\nfunction legacyDisposition(key) { return key.match(/^DISPOSITION:/); }\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/'+name+']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!(kv[1].match(/^TAG:/)) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\n\n\nmodule.exports = function(proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function() {\n    var input, index = null, options = [], callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n\n    var ended = false\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    };\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function(err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src), {windowsHide: true});\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function(err) {\n          if (['ECONNRESET', 'EPIPE', 'EOF'].indexOf(err.code) >= 0) { return; }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function() {\n            input.source.pause();\n            input.source.unpipe(ffprobe.stdin);\n        });\n\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function(target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n\n                legacyTagKeys.forEach(function(tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n\n                legacyDispositionKeys.forEach(function(dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function(data) {\n        stdout += data;\n      });\n\n      ffprobe.stdout.on('close', function() {\n        stdoutClosed = true;\n        handleExit();\n      });\n\n      ffprobe.stderr.on('data', function(data) {\n        stderr += data;\n      });\n\n      ffprobe.stderr.on('close', function() {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}