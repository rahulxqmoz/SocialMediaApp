{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n/*\n *! Custom options methods\n */\n\nmodule.exports = function (proto) {\n  /**\n   * Add custom input option(s)\n   *\n   * When passing a single string or an array, each string containing two\n   * words is split (eg. inputOptions('-option value') is supported) for\n   * compatibility reasons.  This is not the case when passing more than\n   * one argument.\n   *\n   * @example\n   * command.inputOptions('option1');\n   *\n   * @example\n   * command.inputOptions('option1', 'option2');\n   *\n   * @example\n   * command.inputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#inputOptions\n   * @category Custom options\n   * @aliases addInputOption,addInputOptions,withInputOption,withInputOptions,inputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addInputOption = proto.addInputOptions = proto.withInputOption = proto.withInputOptions = proto.inputOption = proto.inputOptions = function (options) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n    var doSplit = true;\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n    this._currentInput.options(options.reduce(function (options, option) {\n      var split = String(option).split(' ');\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n      return options;\n    }, []));\n    return this;\n  };\n\n  /**\n   * Add custom output option(s)\n   *\n   * @example\n   * command.outputOptions('option1');\n   *\n   * @example\n   * command.outputOptions('option1', 'option2');\n   *\n   * @example\n   * command.outputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#outputOptions\n   * @category Custom options\n   * @aliases addOutputOption,addOutputOptions,addOption,addOptions,withOutputOption,withOutputOptions,withOption,withOptions,outputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addOutputOption = proto.addOutputOptions = proto.addOption = proto.addOptions = proto.withOutputOption = proto.withOutputOptions = proto.withOption = proto.withOptions = proto.outputOption = proto.outputOptions = function (options) {\n    var doSplit = true;\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n    this._currentOutput.options(options.reduce(function (options, option) {\n      var split = String(option).split(' ');\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n      return options;\n    }, []));\n    return this;\n  };\n\n  /**\n   * Specify a complex filtergraph\n   *\n   * Calling this method will override any previously set filtergraph, but you can set\n   * as many filters as needed in one call.\n   *\n   * @example <caption>Overlay an image over a video (using a filtergraph string)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter('[0:v][1:v]overlay[out]', ['out']);\n   *\n   * @example <caption>Overlay an image over a video (using a filter array)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter([{\n   *       filter: 'overlay',\n   *       inputs: ['0:v', '1:v'],\n   *       outputs: ['out']\n   *     }], ['out']);\n   *\n   * @example <caption>Split video into RGB channels and output a 3x1 video with channels side to side</caption>\n   *  ffmpeg()\n   *    .input('video.avi')\n   *    .complexFilter([\n   *      // Duplicate video stream 3 times into streams a, b, and c\n   *      { filter: 'split', options: '3', outputs: ['a', 'b', 'c'] },\n   *\n   *      // Create stream 'red' by cancelling green and blue channels from stream 'a'\n   *      { filter: 'lutrgb', options: { g: 0, b: 0 }, inputs: 'a', outputs: 'red' },\n   *\n   *      // Create stream 'green' by cancelling red and blue channels from stream 'b'\n   *      { filter: 'lutrgb', options: { r: 0, b: 0 }, inputs: 'b', outputs: 'green' },\n   *\n   *      // Create stream 'blue' by cancelling red and green channels from stream 'c'\n   *      { filter: 'lutrgb', options: { r: 0, g: 0 }, inputs: 'c', outputs: 'blue' },\n   *\n   *      // Pad stream 'red' to 3x width, keeping the video on the left, and name output 'padded'\n   *      { filter: 'pad', options: { w: 'iw*3', h: 'ih' }, inputs: 'red', outputs: 'padded' },\n   *\n   *      // Overlay 'green' onto 'padded', moving it to the center, and name output 'redgreen'\n   *      { filter: 'overlay', options: { x: 'w', y: 0 }, inputs: ['padded', 'green'], outputs: 'redgreen'},\n   *\n   *      // Overlay 'blue' onto 'redgreen', moving it to the right\n   *      { filter: 'overlay', options: { x: '2*w', y: 0 }, inputs: ['redgreen', 'blue']},\n   *    ]);\n   *\n   * @method FfmpegCommand#complexFilter\n   * @category Custom options\n   * @aliases filterGraph\n   *\n   * @param {String|Array} spec filtergraph string or array of filter specification\n   *   objects, each having the following properties:\n   * @param {String} spec.filter filter name\n   * @param {String|Array} [spec.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [spec.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [spec.options] filter options, can be omitted to not set any options\n   * @param {Array} [map] (array of) stream specifier(s) from the graph to include in\n   *   ffmpeg output, defaults to ffmpeg automatically choosing the first matching streams.\n   * @return FfmpegCommand\n   */\n  proto.filterGraph = proto.complexFilter = function (spec, map) {\n    this._complexFilters.clear();\n    if (!Array.isArray(spec)) {\n      spec = [spec];\n    }\n    this._complexFilters('-filter_complex', utils.makeFilterStrings(spec).join(';'));\n    if (Array.isArray(map)) {\n      var self = this;\n      map.forEach(function (streamSpec) {\n        self._complexFilters('-map', streamSpec.replace(utils.streamRegexp, '[$1]'));\n      });\n    } else if (typeof map === 'string') {\n      this._complexFilters('-map', map.replace(utils.streamRegexp, '[$1]'));\n    }\n    return this;\n  };\n};","map":{"version":3,"names":["utils","require","module","exports","proto","addInputOption","addInputOptions","withInputOption","withInputOptions","inputOption","inputOptions","options","_currentInput","Error","doSplit","arguments","length","slice","call","Array","isArray","reduce","option","split","String","push","addOutputOption","addOutputOptions","addOption","addOptions","withOutputOption","withOutputOptions","withOption","withOptions","outputOption","outputOptions","_currentOutput","filterGraph","complexFilter","spec","map","_complexFilters","clear","makeFilterStrings","join","self","forEach","streamSpec","replace","streamRegexp"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/options/custom.js"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n\n/*\n *! Custom options methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add custom input option(s)\n   *\n   * When passing a single string or an array, each string containing two\n   * words is split (eg. inputOptions('-option value') is supported) for\n   * compatibility reasons.  This is not the case when passing more than\n   * one argument.\n   *\n   * @example\n   * command.inputOptions('option1');\n   *\n   * @example\n   * command.inputOptions('option1', 'option2');\n   *\n   * @example\n   * command.inputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#inputOptions\n   * @category Custom options\n   * @aliases addInputOption,addInputOptions,withInputOption,withInputOptions,inputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addInputOption =\n  proto.addInputOptions =\n  proto.withInputOption =\n  proto.withInputOptions =\n  proto.inputOption =\n  proto.inputOptions = function(options) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentInput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Add custom output option(s)\n   *\n   * @example\n   * command.outputOptions('option1');\n   *\n   * @example\n   * command.outputOptions('option1', 'option2');\n   *\n   * @example\n   * command.outputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#outputOptions\n   * @category Custom options\n   * @aliases addOutputOption,addOutputOptions,addOption,addOptions,withOutputOption,withOutputOptions,withOption,withOptions,outputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addOutputOption =\n  proto.addOutputOptions =\n  proto.addOption =\n  proto.addOptions =\n  proto.withOutputOption =\n  proto.withOutputOptions =\n  proto.withOption =\n  proto.withOptions =\n  proto.outputOption =\n  proto.outputOptions = function(options) {\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentOutput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Specify a complex filtergraph\n   *\n   * Calling this method will override any previously set filtergraph, but you can set\n   * as many filters as needed in one call.\n   *\n   * @example <caption>Overlay an image over a video (using a filtergraph string)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter('[0:v][1:v]overlay[out]', ['out']);\n   *\n   * @example <caption>Overlay an image over a video (using a filter array)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter([{\n   *       filter: 'overlay',\n   *       inputs: ['0:v', '1:v'],\n   *       outputs: ['out']\n   *     }], ['out']);\n   *\n   * @example <caption>Split video into RGB channels and output a 3x1 video with channels side to side</caption>\n   *  ffmpeg()\n   *    .input('video.avi')\n   *    .complexFilter([\n   *      // Duplicate video stream 3 times into streams a, b, and c\n   *      { filter: 'split', options: '3', outputs: ['a', 'b', 'c'] },\n   *\n   *      // Create stream 'red' by cancelling green and blue channels from stream 'a'\n   *      { filter: 'lutrgb', options: { g: 0, b: 0 }, inputs: 'a', outputs: 'red' },\n   *\n   *      // Create stream 'green' by cancelling red and blue channels from stream 'b'\n   *      { filter: 'lutrgb', options: { r: 0, b: 0 }, inputs: 'b', outputs: 'green' },\n   *\n   *      // Create stream 'blue' by cancelling red and green channels from stream 'c'\n   *      { filter: 'lutrgb', options: { r: 0, g: 0 }, inputs: 'c', outputs: 'blue' },\n   *\n   *      // Pad stream 'red' to 3x width, keeping the video on the left, and name output 'padded'\n   *      { filter: 'pad', options: { w: 'iw*3', h: 'ih' }, inputs: 'red', outputs: 'padded' },\n   *\n   *      // Overlay 'green' onto 'padded', moving it to the center, and name output 'redgreen'\n   *      { filter: 'overlay', options: { x: 'w', y: 0 }, inputs: ['padded', 'green'], outputs: 'redgreen'},\n   *\n   *      // Overlay 'blue' onto 'redgreen', moving it to the right\n   *      { filter: 'overlay', options: { x: '2*w', y: 0 }, inputs: ['redgreen', 'blue']},\n   *    ]);\n   *\n   * @method FfmpegCommand#complexFilter\n   * @category Custom options\n   * @aliases filterGraph\n   *\n   * @param {String|Array} spec filtergraph string or array of filter specification\n   *   objects, each having the following properties:\n   * @param {String} spec.filter filter name\n   * @param {String|Array} [spec.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [spec.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [spec.options] filter options, can be omitted to not set any options\n   * @param {Array} [map] (array of) stream specifier(s) from the graph to include in\n   *   ffmpeg output, defaults to ffmpeg automatically choosing the first matching streams.\n   * @return FfmpegCommand\n   */\n  proto.filterGraph =\n  proto.complexFilter = function(spec, map) {\n    this._complexFilters.clear();\n\n    if (!Array.isArray(spec)) {\n      spec = [spec];\n    }\n\n    this._complexFilters('-filter_complex', utils.makeFilterStrings(spec).join(';'));\n\n    if (Array.isArray(map)) {\n      var self = this;\n      map.forEach(function(streamSpec) {\n        self._complexFilters('-map', streamSpec.replace(utils.streamRegexp, '[$1]'));\n      });\n    } else if (typeof map === 'string') {\n      this._complexFilters('-map', map.replace(utils.streamRegexp, '[$1]'));\n    }\n\n    return this;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}