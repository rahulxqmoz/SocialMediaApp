{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar PassThrough = require('stream').PassThrough;\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile = proto.save = function (output) {\n    this.output(output).run();\n    return this;\n  };\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream = proto.pipe = proto.stream = function (stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n      stream = new PassThrough();\n    }\n    this.output(stream, options).run();\n    return stream;\n  };\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots = proto.thumbnail = proto.thumbnails = proto.screenshot = proto.screenshots = function (config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || {\n      count: 1\n    };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push(interval * (i + 1) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function (err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n    async.waterfall([\n    // Compute percent timemarks if any\n    function computeTimemarks(next) {\n      if (config.timemarks.some(function (t) {\n        return ('' + t).match(/^[\\d.]+%$/);\n      })) {\n        if (typeof source !== 'string') {\n          return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n        }\n        getMetadata(function (err, meta) {\n          if (err) {\n            next(err);\n          } else {\n            // Select video stream with the highest resolution\n            var vstream = meta.streams.reduce(function (biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, {\n              width: 0,\n              height: 0\n            });\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot take screenshots'));\n            }\n            var duration = Number(vstream.duration);\n            if (isNaN(duration)) {\n              duration = Number(meta.format.duration);\n            }\n            if (isNaN(duration)) {\n              return next(new Error('Could not get input duration, please specify fixed timemarks'));\n            }\n            config.timemarks = config.timemarks.map(function (mark) {\n              if (('' + mark).match(/^([\\d.]+)%$/)) {\n                return duration * parseFloat(mark) / 100;\n              } else {\n                return mark;\n              }\n            });\n            next();\n          }\n        });\n      } else {\n        next();\n      }\n    },\n    // Turn all timemarks into numbers and sort them\n    function normalizeTimemarks(next) {\n      config.timemarks = config.timemarks.map(function (mark) {\n        return utils.timemarkToSeconds(mark);\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      next();\n    },\n    // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n    function fixPattern(next) {\n      var pattern = config.filename || 'tn.png';\n      if (pattern.indexOf('.') === -1) {\n        pattern += '.png';\n      }\n      if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n        var ext = path.extname(pattern);\n        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n      }\n      next(null, pattern);\n    },\n    // Replace filename tokens (%f, %b) in pattern\n    function replaceFilenameTokens(pattern, next) {\n      if (pattern.match(/%[bf]/)) {\n        if (typeof source !== 'string') {\n          return next(new Error('Cannot replace %f or %b when using an input stream'));\n        }\n        pattern = pattern.replace(/%f/g, path.basename(source)).replace(/%b/g, path.basename(source, path.extname(source)));\n      }\n      next(null, pattern);\n    },\n    // Compute size if needed\n    function getSize(pattern, next) {\n      if (pattern.match(/%[whr]/)) {\n        if (fixedSize) {\n          return next(null, pattern, fixedSize[1], fixedSize[2]);\n        }\n        getMetadata(function (err, meta) {\n          if (err) {\n            return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n          }\n          var vstream = meta.streams.reduce(function (biggest, stream) {\n            if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n              return stream;\n            } else {\n              return biggest;\n            }\n          }, {\n            width: 0,\n            height: 0\n          });\n          if (vstream.width === 0) {\n            return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n          }\n          var width = vstream.width;\n          var height = vstream.height;\n          if (fixedWidth) {\n            height = height * Number(fixedWidth[1]) / width;\n            width = Number(fixedWidth[1]);\n          } else if (fixedHeight) {\n            width = width * Number(fixedHeight[1]) / height;\n            height = Number(fixedHeight[1]);\n          } else if (percentSize) {\n            width = width * Number(percentSize[1]) / 100;\n            height = height * Number(percentSize[1]) / 100;\n          }\n          next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n        });\n      } else {\n        next(null, pattern, -1, -1);\n      }\n    },\n    // Replace size tokens (%w, %h, %r) in pattern\n    function replaceSizeTokens(pattern, width, height, next) {\n      pattern = pattern.replace(/%r/g, '%wx%h').replace(/%w/g, width).replace(/%h/g, height);\n      next(null, pattern);\n    },\n    // Replace variable tokens in pattern (%s, %i) and generate filename list\n    function replaceVariableTokens(pattern, next) {\n      var filenames = config.timemarks.map(function (t, i) {\n        return pattern.replace(/%s/g, utils.timemarkToSeconds(t)).replace(/%(0*)i/g, function (match, padding) {\n          var idx = '' + (i + 1);\n          return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n        });\n      });\n      self.emit('filenames', filenames);\n      next(null, filenames);\n    },\n    // Create output directory\n    function createDirectory(filenames, next) {\n      fs.exists(config.folder, function (exists) {\n        if (!exists) {\n          fs.mkdir(config.folder, function (err) {\n            if (err) {\n              next(err);\n            } else {\n              next(null, filenames);\n            }\n          });\n        } else {\n          next(null, filenames);\n        }\n      });\n    }], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters = self._currentOutput.sizeFilters.get().map(function (f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n          f.outputs = 'size' + i;\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n        self.output(path.join(config.folder, filenames[i])).frames(1).map(stream);\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n      self.complexFilter(filters);\n      self.run();\n    });\n    return this;\n  };\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile = proto.concatenate = proto.concat = function (target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function (input) {\n      return !input.isStream;\n    })[0];\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function (err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n      var hasAudioStreams = data.streams.some(function (stream) {\n        return stream.codec_type === 'audio';\n      });\n      var hasVideoStreams = data.streams.some(function (stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options).complexFilter({\n        filter: 'concat',\n        options: {\n          n: self._inputs.length,\n          v: hasVideoStreams ? 1 : 0,\n          a: hasAudioStreams ? 1 : 0\n        }\n      }).run();\n    });\n    return this;\n  };\n};","map":{"version":3,"names":["fs","require","path","PassThrough","async","utils","module","exports","recipes","proto","saveToFile","save","output","run","writeToStream","pipe","stream","options","undefined","process","version","match","Error","takeScreenshots","thumbnail","thumbnails","screenshot","screenshots","config","folder","self","source","_currentInput","count","timemarks","timestamps","interval","i","push","fixedSize","size","fixedWidth","fixedHeight","percentSize","metadata","getMetadata","cb","ffprobe","err","meta","waterfall","computeTimemarks","next","some","t","vstream","streams","reduce","biggest","codec_type","width","height","duration","Number","isNaN","format","map","mark","parseFloat","normalizeTimemarks","timemarkToSeconds","sort","a","b","fixPattern","pattern","filename","indexOf","length","ext","extname","join","dirname","basename","replaceFilenameTokens","replace","getSize","Math","round","replaceSizeTokens","replaceVariableTokens","filenames","padding","idx","substr","max","emit","createDirectory","exists","mkdir","runCommand","split","filters","filter","outputs","sizeFilters","_currentOutput","get","f","inputs","concat","clear","first","seekInput","frames","seek","complexFilter","mergeToFile","concatenate","target","fileInput","_inputs","input","isStream","data","hasAudioStreams","hasVideoStreams","n","v"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/recipes.js"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar PassThrough = require('stream').PassThrough;\nvar async = require('async');\nvar utils = require('./utils');\n\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile =\n  proto.save = function(output) {\n    this.output(output).run();\n    return this;\n  };\n\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream =\n  proto.pipe =\n  proto.stream = function(stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots =\n  proto.thumbnail =\n  proto.thumbnails =\n  proto.screenshot =\n  proto.screenshots = function(config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || { count: 1 };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push((interval * (i + 1)) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function(err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([\n      // Compute percent timemarks if any\n      function computeTimemarks(next) {\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              next(err);\n            } else {\n              // Select video stream with the highest resolution\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                  return stream;\n                } else {\n                  return biggest;\n                }\n              }, { width: 0, height: 0 });\n\n              if (vstream.width === 0) {\n                return next(new Error('No video stream in input, cannot take screenshots'));\n              }\n\n              var duration = Number(vstream.duration);\n              if (isNaN(duration)) {\n                duration = Number(meta.format.duration);\n              }\n\n              if (isNaN(duration)) {\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n              }\n\n              config.timemarks = config.timemarks.map(function(mark) {\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n                  return duration * parseFloat(mark) / 100;\n                } else {\n                  return mark;\n                }\n              });\n\n              next();\n            }\n          });\n        } else {\n          next();\n        }\n      },\n\n      // Turn all timemarks into numbers and sort them\n      function normalizeTimemarks(next) {\n        config.timemarks = config.timemarks.map(function(mark) {\n          return utils.timemarkToSeconds(mark);\n        }).sort(function(a, b) { return a - b; });\n\n        next();\n      },\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n      function fixPattern(next) {\n        var pattern = config.filename || 'tn.png';\n\n        if (pattern.indexOf('.') === -1) {\n          pattern += '.png';\n        }\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n          var ext = path.extname(pattern);\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n        }\n\n        next(null, pattern);\n      },\n\n      // Replace filename tokens (%f, %b) in pattern\n      function replaceFilenameTokens(pattern, next) {\n        if (pattern.match(/%[bf]/)) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n          }\n\n          pattern = pattern\n            .replace(/%f/g, path.basename(source))\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n        }\n\n        next(null, pattern);\n      },\n\n      // Compute size if needed\n      function getSize(pattern, next) {\n        if (pattern.match(/%[whr]/)) {\n          if (fixedSize) {\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n            }\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, { width: 0, height: 0 });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n            }\n\n            var width = vstream.width;\n            var height = vstream.height;\n\n            if (fixedWidth) {\n              height = height * Number(fixedWidth[1]) / width;\n              width = Number(fixedWidth[1]);\n            } else if (fixedHeight) {\n              width = width * Number(fixedHeight[1]) / height;\n              height = Number(fixedHeight[1]);\n            } else if (percentSize) {\n              width = width * Number(percentSize[1]) / 100;\n              height = height * Number(percentSize[1]) / 100;\n            }\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n          });\n        } else {\n          next(null, pattern, -1, -1);\n        }\n      },\n\n      // Replace size tokens (%w, %h, %r) in pattern\n      function replaceSizeTokens(pattern, width, height, next) {\n        pattern = pattern\n          .replace(/%r/g, '%wx%h')\n          .replace(/%w/g, width)\n          .replace(/%h/g, height);\n\n        next(null, pattern);\n      },\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n      function replaceVariableTokens(pattern, next) {\n        var filenames = config.timemarks.map(function(t, i) {\n          return pattern\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n            .replace(/%(0*)i/g, function(match, padding) {\n              var idx = '' + (i + 1);\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n            });\n        });\n\n        self.emit('filenames', filenames);\n        next(null, filenames);\n      },\n\n      // Create output directory\n      function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }\n    ], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i]))\n          .frames(1)\n          .map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile =\n  proto.concatenate =\n  proto.concat = function(target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function(input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'audio';\n      });\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options)\n        .complexFilter({\n          filter: 'concat',\n          options: {\n            n: self._inputs.length,\n            v: hasVideoStreams ? 1 : 0,\n            a: hasAudioStreams ? 1 : 0\n          }\n        })\n        .run();\n    });\n\n    return this;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}