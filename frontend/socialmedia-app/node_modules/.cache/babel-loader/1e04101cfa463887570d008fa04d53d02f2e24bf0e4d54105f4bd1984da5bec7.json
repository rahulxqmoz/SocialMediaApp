{"ast":null,"code":"/*jshint node:true*/\n'use strict';\n\nvar exec = require('child_process').exec;\nvar isWindows = require('os').platform().match(/win(32|64)/);\nvar which = require('which');\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for (var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if (typeof value === 'undefined') return null;\n    progress[key] = value;\n  }\n  return progress;\n}\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function (source, dest) {\n    Object.keys(source).forEach(function (key) {\n      dest[key] = source[key];\n    });\n  },\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function () {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function () {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function () {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function () {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function (arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function (arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function () {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n    return argfunc;\n  },\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function (filters) {\n    return filters.map(function (filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function (streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function (option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function (option) {\n            var value = filterSpec.options[option];\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function (streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n      return filterString;\n    });\n  },\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function (name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n    which(name, function (err, result) {\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function (timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n    return secs;\n  },\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function (command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n    var format, dur, audio, video;\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n      inputStack[inputIndex] = {\n        format: format[1],\n        audio: '',\n        video: '',\n        duration: ''\n      };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function (command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration)) ret.percent = utils.timemarkToSeconds(ret.timemark) / duration * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function (stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function (messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function (maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false;\n    var max = maxLines - 1;\n    function emit(line) {\n      cbs.forEach(function (cb) {\n        cb(line);\n      });\n    }\n    return {\n      callback: function (cb) {\n        lines.forEach(function (l) {\n          cb(l);\n        });\n        cbs.push(cb);\n      },\n      append: function (str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n        var newLines = str.split(nlRegexp);\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n          current = newLines.pop();\n          newLines.forEach(function (l) {\n            emit(l);\n            lines.push(l);\n          });\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n      get: function () {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n      close: function () {\n        if (closed) return;\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n          current = null;\n        }\n        closed = true;\n      }\n    };\n  }\n};","map":{"version":3,"names":["exec","require","isWindows","platform","match","which","nlRegexp","streamRegexp","filterEscapeRegexp","whichCache","parseProgressLine","line","progress","replace","trim","progressParts","split","i","length","progressSplit","key","value","utils","module","exports","copy","source","dest","Object","keys","forEach","args","list","argfunc","arguments","Array","isArray","concat","slice","call","clear","get","find","arg","count","index","indexOf","remove","splice","clone","cloned","makeFilterStrings","filters","map","filterSpec","filterString","inputs","streamSpec","join","filter","options","option","outputs","name","callback","err","result","timemarkToSeconds","timemark","Number","parts","secs","pop","extractCodecData","command","stderrLine","codecsObject","inputPattern","durPattern","audioPattern","videoPattern","inputStack","inputIndex","inInput","format","dur","audio","video","duration","audio_details","video_details","test","emit","apply","extractProgress","ret","frames","parseInt","frame","currentFps","fps","currentKbps","bitrate","parseFloat","targetSize","size","Lsize","time","_ffprobeData","isNaN","percent","extractError","stderr","reduce","messages","message","charAt","push","linesRing","maxLines","cbs","lines","current","closed","max","cb","l","append","str","Buffer","newLines","shift","close"],"sources":["H:/SecondProject-DjangoReact/frontend/socialmedia-app/node_modules/fluent-ffmpeg/lib/utils.js"],"sourcesContent":["/*jshint node:true*/\n'use strict';\n\nvar exec = require('child_process').exec;\nvar isWindows = require('os').platform().match(/win(32|64)/);\nvar which = require('which');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line  = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for(var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if(typeof value === 'undefined')\n      return null;\n\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n      dest[key] = source[key];\n    });\n  },\n\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function() {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function() {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function() {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function() {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function() {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function(filters) {\n    return filters.map(function(filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function(option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function(option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function(name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function(err, result){\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function(timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function(command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n\n      inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function(command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration))\n          ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function(stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function(messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function(cb) { cb(line); });\n    }\n\n    return {\n      callback: function(cb) {\n        lines.forEach(function(l) { cb(l); });\n        cbs.push(cb);\n      },\n\n      append: function(str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n\n          newLines.forEach(function(l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n\n      get: function() {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n\n      close: function() {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}